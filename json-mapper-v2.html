<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>data 2 sound</title>
    <link rel="stylesheet" href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #fff;
        }
        
        .section {
            margin-bottom: 40px;
            padding-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .section:last-of-type {
            border-bottom: none;
        }
        
        .section-header {
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #000;
        }
        
        .settings-drawer {
            border: 1px solid #e0e0e0;
            background: #f5f5f5;
            margin-bottom: 20px;
        }
        
        .settings-drawer-header {
            padding: 12px 16px;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .settings-drawer-header:hover {
            background: #fafafa;
        }
        
        .settings-drawer-content {
            padding: 20px;
            display: none;
        }
        
        .settings-drawer-content.open {
            display: block;
        }
        
        .drawer-toggle {
            font-size: 14px;
            transition: transform 0.2s;
        }
        
        .drawer-toggle.open {
            transform: rotate(180deg);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .content-wrapper {
                padding: 12px !important;
                max-width: 100% !important;
            }
            
            h1 {
                font-size: 2rem !important;
            }
            
            #playDataBtn {
                min-width: 140px !important;
                padding: 12px 16px !important;
                font-size: 18px !important;
            }
            
            #playDataBtn #playIcon, #playDataBtn #playText {
                font-size: 18px !important;
            }
            
            #templateSelector {
                width: 100% !important;
            }
            
            .settings-drawer-content {
                padding: 12px !important;
            }
            
            #patchViz {
                overflow-x: auto;
            }
        }
        
        @media (min-width: 769px) and (max-width: 1200px) {
            #templateSelector {
                width: 500px !important;
            }
        }
        
        #jsonEditor {
            width: 100%;
            height: 400px;
            padding: 12px;
            border: 1px solid #000;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            background: #fafafa;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 40px;
            text-align: center;
            color: #999;
            margin-bottom: 20px;
            transition: all 0.2s;
        }
        
        .drop-zone.drag-over {
            border-color: #000;
            background: #f5f5f5;
            color: #000;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }
        
        .data-table th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 2px solid #000;
            font-weight: 600;
            background: #f5f5f5;
        }
        
        .data-table td {
            padding: 6px 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .data-table tr:hover {
            background: #fafafa;
        }
        
        .json-syntax {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .json-key { color: #0066cc; }
        .json-string { color: #008800; }
        .json-number { color: #cc0000; }
        .json-boolean { color: #cc0066; }
        .json-null { color: #999; }
        
        .content-wrapper {
            padding-bottom: 20px;
        }
        
        #audioVisualizer {
            flex: 1;
            height: 60px;
            border: 2px solid #000;
            background: #fff;
            display: none;
        }
        
        #audioVisualizer.active {
            display: block;
        }
        
        .playback-labels {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 10px;
            color: #666;
            min-width: 80px;
            text-align: center;
        }
        
        .playback-value {
            font-size: 14px;
            color: #000;
            font-weight: 600;
        }
        
        .node-rect {
            fill: #fff;
            stroke: none;
            cursor: default;
        }
        
        .node-rect:hover {
            fill: #f0f0f0;
        }
        
        .node-rect.selected {
            fill: #e0e0ff;
        }
        
        .node-text {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            text-anchor: middle;
            font-weight: 600;
        }
        
        .node-rect.playing {
            fill: #d0ffd0;
        }
        
        .node-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8px;
            fill: #666;
            font-weight: 400;
            pointer-events: none;
            text-anchor: middle;
        }
        
        .port {
            fill: #000;
            cursor: pointer;
        }
        
        .port:hover {
            fill: #00f;
        }
        
        .connection-path {
            stroke: #000;
            stroke-width: 2;
            fill: none;
            cursor: pointer;
            stroke-dasharray: 5, 5; /* MaxMSP-style alternating dashes */
        }
        
        .connection-path:hover {
            stroke: #00f;
            stroke-width: 3;
            stroke-dasharray: 5, 5;
        }
        
        .connection-path.active {
            stroke: #0f0;
            stroke-width: 3;
            stroke-dasharray: 5, 5;
            animation: pulse 0.5s ease;
        }
        
        .node-rect.playing {
            fill: #d0ffd0;
            stroke: #0f0;
            stroke-width: 3;
        }
        
        .node-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            fill: #000;
            font-weight: 400;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .view-toggle {
            display: inline-flex;
            border: 1px solid #000;
            overflow: hidden;
        }
        
        .view-toggle button {
            padding: 6px 16px;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 12px;
        }
        
        .view-toggle button.active {
            background: #000;
            color: #fff;
        }
        
        .view-toggle button:hover:not(.active) {
            background: #f0f0f0;
        }
        
        #connectionEditor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #000;
            padding: 20px;
            z-index: 2000;
            display: none;
        }
        
        #connectionEditor.active {
            display: block;
        }
        
        #editorOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            display: none;
        }
        
        #editorOverlay.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="pa3 content-wrapper" style="max-width: 1100px; margin: 0 auto;">
        <h1 class="f1 mb2 mt0 tc" style="font-family: 'Lucida Blackletter', 'Blackletter686', serif; font-weight: normal;">data 2 sound</h1>
        <p class="tc f6 gray mb3" style="max-width: 600px; margin-left: auto; margin-right: auto;">
            Turn any dataset into sound. Map data fields to audio parameters and hear patterns emerge. 
            <a href="https://github.com/luismqueral/data-2-sound" target="_blank" class="black underline">Learn more ‚Üí</a>
        </p>
        
        <!-- Data Selection -->
        <div class="mb4">
            <div class="tc mb2">
                <select id="templateSelector" class="pa2 ba b--black f6" style="width: 600px; max-width: 90%;">
                    <option value="">-- Select Dataset --</option>
                    
                    <optgroup label="üåç Earthquakes - All Magnitudes (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson">All Earthquakes: Past Hour (Real-time)</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson">All Earthquakes: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson">All Earthquakes: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson">All Earthquakes: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="üî¥ Earthquakes - Magnitude 4.5+ (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_hour.geojson">M4.5+: Past Hour</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson">M4.5+: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson">M4.5+: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_month.geojson">M4.5+: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="üü† Earthquakes - Magnitude 2.5+ (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_hour.geojson">M2.5+: Past Hour</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_day.geojson">M2.5+: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson">M2.5+: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_month.geojson">M2.5+: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="‚ö†Ô∏è Earthquakes - Significant Only (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_hour.geojson">Significant: Past Hour</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_day.geojson">Significant: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_week.geojson">Significant: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.geojson">Significant: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="üì¶ Earthquakes - Archived">
                        <option value="datasets/earthquakes-week.geojson">Local Archive: Weekly Snapshot (1600+ events)</option>
                    </optgroup>
                    
                    <optgroup label="üèóÔ∏è Urban Development">
                        <option value="datasets/Housing_and_Building_Permits_2019-Present.geojson">Baltimore Housing Permits (265K+ records)</option>
                    </optgroup>
                    
                    <optgroup label="üåå Space">
                        <option value="datasets/exoplanets.csv">NASA Exoplanets (6000+ planets)</option>
                        <option value="https://api.nasa.gov/neo/rest/v1/feed?start_date=2024-11-12&end_date=2024-11-12&api_key=DEMO_KEY">NASA: Near Earth Objects - Today</option>
                        <option value="http://api.open-notify.org/iss-now.json">ISS Location (Real-time)</option>
                        <option value="http://api.open-notify.org/astros.json">Astronauts in Space (Real-time)</option>
                    </optgroup>
                </select>
            </div>
            <div class="tc f6 gray mb3">
                Copy/paste or drag-and-drop dataset to upload your own
            </div>
            <div class="tc mb2">
                <span id="parseStatus" class="f6 gray"></span>
            </div>
            <div class="tc">
                <a id="datasetSourceLink" href="#" target="_blank" class="f7 gray underline" style="display: none;">View dataset source ‚Üí</a>
            </div>
            
            <div id="dropZone" class="drop-zone" style="display: none;">
                Drop JSON or CSV file here
            </div>
            
            <div id="customJsonContainer" style="display: none;">
                <textarea id="jsonEditor" spellcheck="false"></textarea>
                <div class="mt2">
                    <button id="closeEditorBtn" class="pa1 ba b--black bg-white pointer hover-bg-black hover-white f6">Close Editor</button>
                </div>
            </div>
            
            <!-- Data Table Modal -->
            <div id="dataTableModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 2px solid #000; padding: 20px; z-index: 2000; max-width: 90%; max-height: 80%; overflow: auto;">
                <div class="flex items-center justify-between mb3">
                    <h3 class="f4 ma0">Data Preview</h3>
                    <button id="closeTableBtn" class="pa1 ba b--black bg-white pointer hover-bg-black hover-white">Close</button>
                </div>
                <div style="max-height: 500px; overflow-y: auto;">
                    <table class="data-table">
                        <thead id="dataTableHead"></thead>
                        <tbody id="dataTableBody"></tbody>
                    </table>
                </div>
            </div>
            <div id="tableModalOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1999;"></div>
        </div>
        
        <!-- Control Buttons -->
        <div class="mb3 flex items-center justify-center">
            <button id="playDataBtn" disabled class="mr2 ba b--black bg-black white pointer hover-bg-white hover-black" style="width: 240px; padding: 16px 24px; font-size: 24px; height: 64px;">
                <span class="mr2" id="playIcon" style="font-size: 24px;">‚ñ∂</span>
                <span id="playText">Play Data</span>
            </button>
            <div class="mr2 ba b--black-10 flex items-center justify-center" id="itemLabel" style="background: #f5f5f5; padding: 16px 24px; min-width: 120px; height: 64px;">
                <div class="tc">
                    <div style="font-size: 9px; color: #999; letter-spacing: 0.5px; margin-bottom: 2px;">ITEM</div>
                    <div class="playback-value" id="itemValue" style="font-size: 16px; font-weight: 600; color: #000;">--</div>
                </div>
            </div>
            <button id="randomizeMappingsBtn" disabled class="ba b--black bg-white pointer hover-bg-black hover-white" style="padding: 16px 24px; font-size: 16px; min-width: 180px; height: 64px;">
                <span style="margin-right: 4px;">üîÄ</span>Randomize Patch
            </button>
        </div>
        
        <!-- Global Settings Drawer -->
        <div class="settings-drawer">
            <div class="settings-drawer-header" id="settingsDrawerToggle">
                <span class="b f5">Global Settings</span>
                <span class="drawer-toggle" id="drawerToggleIcon">‚ñº</span>
            </div>
            <div class="settings-drawer-content" id="settingsDrawerContent">
                    
                    <div class="mb3">
                        <label class="db mb2">
                            <span class="db mb1 f6 b">Master Volume:</span>
                            <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.2" class="w-100">
                            <span id="masterVolumeValue" class="f6">0.2 (20%)</span>
                        </label>
                    </div>
                    
                    <div class="mb3" style="padding-bottom: 12px; border-bottom: 2px solid #ddd;">
                        <div class="b mb2 f6">Sound Source</div>
                        <label class="db mb2 f6">
                            <input type="radio" name="soundSource" value="synthesizer" checked class="mr2" id="synthesizerMode">
                            <span>üéπ Synthesizer (Oscillators)</span>
                        </label>
                        <label class="db mb2 f6">
                            <input type="radio" name="soundSource" value="sampler" class="mr2" id="samplerMode">
                            <span>üéµ Sampler (Audio Files)</span>
                        </label>
                        
                        <!-- Sample Upload Section (hidden by default) -->
                        <div id="sampleUploadSection" style="display: none; margin-top: 12px; padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">
                            <div class="mb2">
                                <label class="db mb1 f7 b">Load Audio Sample:</label>
                                <input type="file" id="sampleFileInput" accept="audio/wav,audio/mpeg,audio/mp3,audio/ogg,audio/webm,audio/x-m4a,audio/mp4,.wav,.mp3,.ogg,.webm,.m4a" class="f6 w-100" style="padding: 4px;">
                                <div class="f7 mt1" style="color: #666;">Best: WAV, MP3, OGG | M4A may need conversion</div>
                            </div>
                            
                            <!-- Sample Info Display -->
                            <div id="sampleInfo" style="display: none; margin-top: 8px; padding: 8px; background: white; border: 1px solid #ccc; border-radius: 3px;">
                                <div class="f7 mb1">
                                    <span class="b">üìÑ File:</span> <span id="sampleFileName">--</span>
                                </div>
                                <div class="f7 mb1">
                                    <span class="b">‚è± Duration:</span> <span id="sampleDuration">--</span>
                                </div>
                                <div class="f7">
                                    <span class="b">üìä Format:</span> <span id="sampleFormat">--</span>
                                </div>
                                <button id="clearSampleBtn" class="mt2 pa1 f7 ba b--black bg-white pointer hover-bg-black hover-white" style="width: 100%;">
                                    Clear Sample
                                </button>
                            </div>
                            
                            <div id="sampleLoadError" style="display: none; margin-top: 8px; padding: 8px; background: #ffe6e6; border: 1px solid #cc0000; border-radius: 3px; color: #cc0000; white-space: pre-line;" class="f7">
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb3">
                        <div class="b mb2 f6">Smart Processing</div>
                        <label class="db mb2 f6">
                            <input type="checkbox" id="adaptiveNormalization" checked class="mr2">
                            <span>Adaptive Normalization</span>
                        </label>
                        <label class="db mb2 f6">
                            <input type="checkbox" id="rhythmicQuantization" class="mr2">
                            <span>Rhythmic Quantization</span>
                        </label>
                        <label class="db mb2 f6">
                            <input type="checkbox" id="pitchQuantization" checked class="mr2">
                            <span>Pitch Quantization (Scale)</span>
                        </label>
                    </div>
                    
                    <div class="mb3" id="scaleContainer" style="display: none;">
                        <div class="b mb2 f6">Scale</div>
                        <select id="scaleSelector" class="w-100 pa1 ba b--black f6">
                            <option value="pentatonic" selected>Pentatonic (5 notes)</option>
                            <option value="major">Major Scale</option>
                            <option value="minor">Natural Minor</option>
                            <option value="dorian">Dorian Mode</option>
                            <option value="mixolydian">Mixolydian Mode</option>
                            <option value="chromatic">Chromatic (12 notes)</option>
                        </select>
                    </div>
                    
                    <div class="mb3">
                        <div class="b mb2 f6">Waveform</div>
                        <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #ddd;">
                            <div class="f7 mb1" style="color: #666;">Classic</div>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="sine" checked class="mr1"> Sine
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="square" class="mr1"> Square
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="sawtooth" class="mr1"> Sawtooth
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="triangle" class="mr1"> Triangle
                            </label>
                        </div>
                        <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #ddd;">
                            <div class="f7 mb1" style="color: #666;">Noise</div>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="white-noise" class="mr1"> White Noise
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="pink-noise" class="mr1"> Pink Noise
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="brown-noise" class="mr1"> Brown Noise
                            </label>
                        </div>
                        <div>
                            <div class="f7 mb1" style="color: #666;">Synthesis</div>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="fm" class="mr1"> FM Synthesis
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="additive" class="mr1"> Additive (Harmonics)
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="pwm" class="mr1"> Pulse Width Mod
                            </label>
                        </div>
                    </div>
                    
                    <div class="mb3">
                        <div class="b mb2 f6">Filter</div>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="lowpass" checked class="mr1"> Lowpass
                        </label>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="highpass" class="mr1"> Highpass
                        </label>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="bandpass" class="mr1"> Bandpass
                        </label>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="notch" class="mr1"> Notch
                        </label>
                    </div>
                    
                    <h3 class="f5 mb2 mt3">Playback</h3>
                    <div class="mb3">
                        <label class="db mb2">
                            <span class="db mb1 f6">Master Pitch:</span>
                            <input type="range" id="pitchControl" min="-24" max="24" step="0.1" value="0" class="w-100">
                            <span id="pitchValue" class="f6">0 semitones</span>
                        </label>
                        <label class="db mb2">
                            <span class="db mb1 f6">Speed:</span>
                            <input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1" class="w-100">
                            <span id="speedValue" class="f6">1x</span>
                        </label>
                    </div>
            </div>
        </div>
        
        <!-- Patch View (Full Width) -->
        <div style="background: #fffef0; padding: 20px; border: 1px solid #e0e0e0; margin-bottom: 20px;">
            <h3 class="f5 mt0 mb3">Patch View</h3>
            
            <div id="nodeView">
                <div style="position: relative;">
                    <div id="columnHeaders" style="position: relative; height: 20px; margin-bottom: 10px;">
                        <div id="leftHeader" style="position: absolute; font-family: 'IBM Plex Mono', monospace; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #666; transform: translateX(-50%);">Data Fields</div>
                        <div id="rightHeader" style="position: absolute; font-family: 'IBM Plex Mono', monospace; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #666; transform: translateX(-50%);">Audio Parameters</div>
                    </div>
                    <svg id="patchViz" width="100%" style="background: transparent;"></svg>
                </div>
            </div>
                    
            <div id="formView" style="display: none;">
                <h3 class="f5 mb3 b">Parameter Controls</h3>
                <div class="mb4">
                    <button id="randomizeMappingsBtn2" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize Mappings</button>
                    <button id="randomizeRangesBtn" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize Ranges</button>
                    <button id="randomizeAllBtn" disabled class="pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize All</button>
                </div>
                <div id="mappingControls" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px 30px;"></div>
            </div>
        </div>
        
        <!-- Audio Visualizer Section - Fixed to Bottom -->
        <div id="audioOutputSection" style="position: fixed; bottom: 0; left: 0; right: 0; background: #f5f5f5; padding: 20px; border-top: 2px solid #000; z-index: 1000;">
            <h3 class="f5 mt0 mb3">Audio Output</h3>
            <div style="width: 100%; overflow: hidden;">
                <canvas id="audioVisualizer" style="width: 100%; height: 60px;"></canvas>
            </div>
        </div>
    </div>
    
    <!-- Add padding to bottom of content to prevent overlap with fixed audio output -->
    <div style="height: 140px;"></div>
    
    
    <!-- Connection Editor Modal -->
    <div id="editorOverlay"></div>
    <div id="connectionEditor">
        <h3 class="f5 mb3 b">Edit Connection</h3>
        <div id="editorContent">
            <div class="mb3">
                <label class="db mb2">
                    <span class="db mb1 b f6">Source:</span>
                    <span id="editorSource" class="f6">--</span>
                </label>
                <label class="db mb2">
                    <span class="db mb1 b f6">Target:</span>
                    <span id="editorTarget" class="f6">--</span>
                </label>
            </div>
            <div class="mb3">
                <label class="db mb2">
                    <span class="db mb1 f6">Min:</span>
                    <input type="number" id="editorMin" class="w-100 pa1 ba b--black f6" step="any">
                </label>
                <label class="db mb2">
                    <span class="db mb1 f6">Max:</span>
                    <input type="number" id="editorMax" class="w-100 pa1 ba b--black f6" step="any">
                </label>
                <label class="db mb2">
                    <span class="db mb1 f6">Curve:</span>
                    <select id="editorCurve" class="w-100 pa1 ba b--black f6">
                        <option value="linear">Linear</option>
                        <option value="exponential">Exponential</option>
                        <option value="cubic">Cubic</option>
                        <option value="logarithmic">Logarithmic</option>
                        <option value="inverse">Inverse</option>
                    </select>
                </label>
            </div>
            <div class="flex justify-between">
                <button id="editorDelete" class="pa2 ba b--black bg-white pointer hover-bg-black hover-white">Delete Connection</button>
                <button id="editorClose" class="pa2 ba b--black bg-black white pointer hover-bg-white hover-black">Done</button>
            </div>
        </div>
    </div>

    <script>
        console.log('=== data 2 sound starting ===');
        
        // Datasets are now loaded from /datasets folder via fetch()
        // No more hardcoded data in HTML
        
        const jsonEditor = document.getElementById('jsonEditor');
        
        // Auto-parse function
        function autoParseJSON() {
            const jsonText = jsonEditor.value.trim();
            const parseStatus = document.getElementById('parseStatus');
            const dataTableContainer = document.getElementById('dataTableContainer');
            
            if (!parseStatus) {
                console.error('parseStatus element not found');
                return false;
            }
            
            try {
                let data;
                
                // Detect if input is CSV (starts with non-bracket/brace characters and contains commas/newlines)
                const isLikelyCSV = !jsonText.startsWith('{') && !jsonText.startsWith('[') && 
                                   (jsonText.includes(',') || jsonText.split('\n').length > 1);
                
                if (isLikelyCSV) {
                    // Try parsing as CSV
                    console.log('Detected CSV format, parsing...');
                    data = d3.csvParse(jsonText, d3.autoType);
                    
                    if (!data || data.length === 0) {
                        throw new Error('CSV parsing resulted in empty data');
                    }
                    
                    console.log(`Parsed ${data.length} rows from CSV`);
                    parseStatus.textContent = `‚úì Parsed ${data.length} rows from CSV`;
                    parseStatus.style.color = '#00aa00';
                } else {
                    // Parse as JSON
                    data = JSON.parse(jsonText);
                    parseStatus.textContent = '';
                }
                
                console.log('Parsed data:', data);
                
                // Handle different JSON structures
                let processedData = data;
                
                // If single object with nested data, try to extract array
                if (!Array.isArray(data) && typeof data === 'object') {
                    // Look for array properties
                    const arrayProps = Object.keys(data).filter(key => Array.isArray(data[key]));
                    
                    if (arrayProps.length > 0) {
                        // Use first array found
                        processedData = data[arrayProps[0]];
                        console.log(`Found nested array at '${arrayProps[0]}' with ${processedData.length} items`);
                    } else {
                        // Look for object with many key-value pairs (like exchange rates)
                        const nestedObjects = Object.keys(data).filter(key => 
                            typeof data[key] === 'object' && data[key] !== null && !Array.isArray(data[key])
                        );
                        
                        if (nestedObjects.length > 0) {
                            // Convert first nested object to array of {key, value} pairs
                            const objKey = nestedObjects[0];
                            processedData = Object.entries(data[objKey]).map(([key, value]) => ({
                                key: key,
                                value: value
                            }));
                            console.log(`Converted nested object '${objKey}' to ${processedData.length} items`);
                        } else {
                            // Single object - wrap in array
                            processedData = [data];
                        }
                    }
                }
                
                parsedData = processedData;
                
                // Prepare table data (don't show yet - only when "View Data Table" is clicked)
                displayDataTable(Array.isArray(processedData) ? processedData : [processedData]);
                
                // Extract paths from processed data (not original)
                detectedPaths = extractPaths(processedData);
                numericPaths = detectedPaths.filter(p => p.type === 'number');
                
                console.log(`Data structure: ${Array.isArray(processedData) ? processedData.length + ' items' : 'single object'}`);
                console.log('First item sample:', Array.isArray(processedData) ? processedData[0] : processedData);
                
                console.log('Numeric paths found:', numericPaths.length);
                console.log('All numeric paths with coverage:', numericPaths.map(p => `${p.path} (${(p.coverage * 100).toFixed(0)}%)`));
                
                // Warn if no numeric paths found
                if (numericPaths.length === 0) {
                    console.warn('‚ö†Ô∏è NO NUMERIC PATHS FOUND!');
                    console.warn('This dataset may only contain strings/objects, or data is too deeply nested');
                    console.warn('All detected paths:', detectedPaths.map(p => `${p.path} (${p.type})`));
                    parseStatus.textContent = '‚ö†Ô∏è Warning: No numeric fields found in this dataset';
                    parseStatus.style.color = '#ff6600';
                }
                
                // Apply adaptive normalization if enabled
                const adaptiveCheckbox = document.getElementById('adaptiveNormalization');
                if (adaptiveCheckbox && adaptiveCheckbox.checked) {
                    const dataArray = Array.isArray(processedData) ? processedData : [processedData];
                    
                    numericPaths.forEach(pathObj => {
                        const values = extractValues(dataArray, pathObj.path);
                        const analysis = analyzeDataVariance(values);
                        
                        // Store recommended curve for this path
                        pathObj.recommendedCurve = analysis.curve;
                        pathObj.variance = analysis.coefficient;
                        
                        console.log(`${pathObj.path}: variance=${analysis.coefficient.toFixed(4)}, recommended=${analysis.curve}`);
                    });
                }
                
                // Create controls
                createMappingControls(numericPaths);
                
                // Enable buttons
                const playDataBtn = document.getElementById('playDataBtn');
                if (playDataBtn) playDataBtn.disabled = false;
                
                const randomizeBtn = document.getElementById('randomizeMappingsBtn');
                if (randomizeBtn) randomizeBtn.disabled = false;
                
                const randomizeBtn2 = document.getElementById('randomizeMappingsBtn2');
                if (randomizeBtn2) randomizeBtn2.disabled = false;
                
                const rangesBtn = document.getElementById('randomizeRangesBtn');
                if (rangesBtn) rangesBtn.disabled = false;
                
                const allBtn = document.getElementById('randomizeAllBtn');
                if (allBtn) allBtn.disabled = false;
                
                // Auto-apply smart mapping
                intelligentMapping();
                
                // Clear status (no need to show anything on success)
                parseStatus.textContent = '';
                
                return true;
            } catch (e) {
                console.error('Parse error:', e);
                const errorMsg = `‚úó Invalid JSON/CSV: ${e.message}`;
                parseStatus.textContent = errorMsg;
                parseStatus.style.color = '#cc0000';
                if (dataTableContainer) {
                    dataTableContainer.style.display = 'none';
                }
                return false;
            }
        }
        
        // Paste support - auto-parse on paste
        jsonEditor.addEventListener('paste', (e) => {
            setTimeout(() => {
                autoParseJSON();
            }, 100);
        });
        
        // Auto-parse on any content change (for manual edits)
        let parseTimeout;
        jsonEditor.addEventListener('input', (e) => {
            clearTimeout(parseTimeout);
            parseTimeout = setTimeout(() => {
                const text = jsonEditor.value.trim();
                // Trigger for JSON or CSV-like content
                if (text.startsWith('{') || text.startsWith('[') || (text.includes(',') && text.split('\n').length > 1)) {
                    autoParseJSON();
                }
            }, 1000); // Wait 1 second after typing stops
        });
        
        // Template selector - load from datasets folder
        document.getElementById('templateSelector').addEventListener('change', async (e) => {
            const filePath = e.target.value;
            if (!filePath) {
                // Clear source link if no selection
                document.getElementById('datasetSourceLink').style.display = 'none';
                return;
            }
            
            const parseStatus = document.getElementById('parseStatus');
            parseStatus.textContent = 'Loading...';
            parseStatus.style.color = '#666';
            
            // Show/update dataset source link
            const sourceLink = document.getElementById('datasetSourceLink');
            sourceLink.href = filePath;
            sourceLink.style.display = 'inline';
            
            try {
                // Add cache-busting for APIs to get fresh data
                const isAPI = filePath.startsWith('http://') || filePath.startsWith('https://');
                const fetchURL = isAPI ? `${filePath}${filePath.includes('?') ? '&' : '?'}_t=${Date.now()}` : filePath;
                
                const response = await fetch(fetchURL, {
                    cache: 'no-cache', // Force fresh data
                    headers: isAPI ? {} : undefined
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to load file: ${response.statusText}`);
                }
                
                const contentType = response.headers.get('content-type');
                const text = await response.text();
                
                // Detect file type and load accordingly
                if (filePath.endsWith('.csv')) {
                    // CSV file - load directly into editor
                    jsonEditor.value = text;
                    console.log(`Loaded CSV: ${filePath}`);
                } else if (filePath.endsWith('.json')) {
                    // JSON file - prettify for editor
                    const json = JSON.parse(text);
                    jsonEditor.value = JSON.stringify(json, null, 2);
                    console.log(`Loaded JSON: ${filePath}, items:`, Array.isArray(json) ? json.length : 'object');
                } else if (filePath.endsWith('.geojson')) {
                    // GeoJSON file - prettify for editor
                    const geojson = JSON.parse(text);
                    jsonEditor.value = JSON.stringify(geojson, null, 2);
                    console.log(`Loaded GeoJSON: ${filePath}, features:`, geojson.features?.length || 'N/A');
                }
                
                // Auto-parse after loading
                setTimeout(() => autoParseJSON(), 100);
            } catch (error) {
                console.error('Error loading dataset:', error);
                parseStatus.textContent = `‚úó Error loading file: ${error.message}`;
                parseStatus.style.color = '#cc0000';
            }
        });
        
        // Drag-and-drop file upload
        const dropZone = document.getElementById('dropZone');
        const body = document.body;
        
        // Show drop zone when dragging files over window
        body.addEventListener('dragenter', (e) => {
            e.preventDefault();
            if (e.dataTransfer.types.includes('Files')) {
                dropZone.style.display = 'block';
            }
        });
        
        body.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            if (e.target === dropZone) {
                dropZone.classList.remove('drag-over');
                dropZone.style.display = 'none';
            }
        });
        
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            dropZone.style.display = 'none';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const fileName = file.name.toLowerCase();
                
                console.log('Dropped file:', file.name, 'Type:', file.type);
                
                const parseStatus = document.getElementById('parseStatus');
                parseStatus.textContent = `Loading ${file.name}...`;
                parseStatus.style.color = '#666';
                
                try {
                    const text = await file.text();
                    
                    // Clear dropdown selection and source link
                    document.getElementById('templateSelector').value = '';
                    document.getElementById('datasetSourceLink').style.display = 'none';
                    
                    // Load into editor
                    if (fileName.endsWith('.json') || fileName.endsWith('.geojson')) {
                        const json = JSON.parse(text);
                        jsonEditor.value = JSON.stringify(json, null, 2);
                        console.log('Loaded JSON file:', fileName);
                    } else if (fileName.endsWith('.csv')) {
                        jsonEditor.value = text;
                        console.log('Loaded CSV file:', fileName);
                    } else {
                        // Try as JSON/CSV
                        jsonEditor.value = text;
                        console.log('Loaded file:', fileName);
                    }
                    
                    // Auto-parse
                    setTimeout(() => autoParseJSON(), 100);
                } catch (error) {
                    console.error('Error reading file:', error);
                    parseStatus.textContent = `‚úó Error reading file: ${error.message}`;
                    parseStatus.style.color = '#cc0000';
                }
            }
        });
        
        body.addEventListener('dragleave', (e) => {
            if (e.target === body) {
                dropZone.classList.remove('drag-over');
                dropZone.style.display = 'none';
            }
        });
        
        body.addEventListener('drop', (e) => {
            // Prevent default for any drop outside dropZone
            if (e.target !== dropZone && !dropZone.contains(e.target)) {
                e.preventDefault();
                dropZone.style.display = 'none';
            }
        });
        
        // Global paste support - paste anywhere on page
        document.addEventListener('paste', async (e) => {
            // Check if pasting into textarea already
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                return; // Let default paste behavior happen
            }
            
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text');
            
            if (pastedText && pastedText.trim()) {
                console.log('Pasted data detected, length:', pastedText.length);
                
                // Clear dropdown selection and source link
                document.getElementById('templateSelector').value = '';
                document.getElementById('datasetSourceLink').style.display = 'none';
                
                // Load into editor
                jsonEditor.value = pastedText;
                
                // Auto-parse
                setTimeout(() => autoParseJSON(), 100);
            }
        });
        
        // Settings drawer toggle
        document.getElementById('settingsDrawerToggle').addEventListener('click', () => {
            const content = document.getElementById('settingsDrawerContent');
            const icon = document.getElementById('drawerToggleIcon');
            
            content.classList.toggle('open');
            icon.classList.toggle('open');
        });
        
        // Auto-load default template on page load
        setTimeout(async () => {
            console.log('Auto-loading default dataset...');
            const templateSelector = document.getElementById('templateSelector');
            if (templateSelector) {
                templateSelector.value = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson';
                // Trigger the change event to load the file
                templateSelector.dispatchEvent(new Event('change'));
            }
        }, 100);

        // View toggle (Node vs Form)
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const viewName = e.target.dataset.view;
                
                // Update active button
                document.querySelectorAll('.view-toggle-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                // Toggle views
                if (viewName === 'node') {
                    document.getElementById('nodeView').style.display = 'block';
                    document.getElementById('formView').style.display = 'none';
                } else {
                    document.getElementById('nodeView').style.display = 'none';
                    document.getElementById('formView').style.display = 'block';
                }
            });
        });

        // Manual parse button (for re-parsing after edits)
        document.getElementById('parseDataBtn')?.addEventListener('click', () => {
            autoParseJSON();
        });

        // Display data in table format
        function displayDataTable(data) {
            if (data.length === 0) return;
            
            const head = document.getElementById('dataTableHead');
            const body = document.getElementById('dataTableBody');
            
            if (!head || !body) return;
            
            // Get all keys
            const keys = Object.keys(data[0]);
            
            // Create header
            head.innerHTML = '<tr>' + keys.map(k => `<th>${k}</th>`).join('') + '</tr>';
            
            // Create rows (limit to first 50 for performance)
            body.innerHTML = '';
            const displayData = data.slice(0, 50);
            displayData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = keys.map(k => `<td>${row[k]}</td>`).join('');
                body.appendChild(tr);
            });
            
            if (data.length > 50) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="${keys.length}" style="text-align: center; color: #666;">... ${data.length - 50} more rows ...</td>`;
                body.appendChild(tr);
            }
        }

        // ============================================================================
        // DATA FLOW DOCUMENTATION
        // ============================================================================
        // 
        // 1. DATA LOADING & PARSING
        //    - User selects dataset from dropdown OR drags/pastes data
        //    - autoParseJSON() detects format (JSON/CSV/GeoJSON)
        //    - For GeoJSON: extracts data.features array automatically
        //    - For nested JSON: finds first array property and extracts it
        //    - Result stored in: parsedData (always an array of objects)
        //
        // 2. PATH EXTRACTION & VALIDATION
        //    - extractPaths() recursively walks first item to find all field paths
        //    - Samples up to 20 items to verify field exists across dataset
        //    - Calculates coverage % (how many items have each field)
        //    - Filters out sparse fields (<10% coverage) to avoid null issues
        //    - Separates numeric vs string paths
        //    - Result stored in: detectedPaths, numericPaths
        //
        // 3. VISUALIZATION SETUP
        //    - createNodes() builds node list from numericPaths
        //    - Data nodes (left): one per numeric field with safeId(path)
        //    - Audio nodes (right): one per audio parameter (13 total)
        //    - drawNodes() renders SVG with D3, creates DOM elements
        //    - Each node gets text element with ID: value_${safeId}
        //
        // 4. MAPPING (Smart or Manual)
        //    - Smart mapping analyzes variance/uniqueness to rank "interestingness"
        //    - Assigns best data paths to perceptually important audio params
        //    - Stores in mappings object: { audioParam: { path, min, max, curve } }
        //
        // 5. PLAYBACK & SONIFICATION
        //    - Loops through parsedData array, one item per iteration
        //    - For each item: getValueByPath() extracts values using dot notation
        //    - Values scaled from data range to audio parameter range
        //    - Curve transformations applied (linear/exponential/cubic/log/inverse)
        //    - Web Audio API generates sound with calculated parameters
        //    - updateNodeValues() called to update D3 visualization
        //
        // 6. VISUALIZATION UPDATE (D3)
        //    - For each node, looks up value using getValueByPath()
        //    - Updates text content of DOM element via d3.select()
        //    - Highlights active nodes (green border) if path is mapped
        //    - Shows "--" if value is null/undefined for that item
        //
        // ============================================================================
        
        // Global state
        let parsedData = null;         // Array of data items (after extraction from GeoJSON/nested structures)
        let detectedPaths = [];        // All detected field paths with type info and coverage %
        let numericPaths = [];         // Filtered list of only numeric paths
        let mappings = {};             // Current data-to-audio mappings { audioParam: { path, min, max, curve } }
        let audioContext;              // Web Audio API context
        let isPlaying = false;         // Playback state
        let isPaused = false;          // Pause state
        let currentTimeout;            // For note timing
        let delayNode, delayFeedbackGain, delayWetGain, delayDryGain;  // Audio effect nodes
        let reverbNode, reverbWetGain, reverbDryGain;                   // Reverb nodes
        let previousDelayTime = null;  // Track for analog pitch shifting
        
        // Sampler mode variables
        let samplerMode = false;       // false = synthesizer, true = sampler
        let sampleBuffer = null;       // Decoded audio buffer
        let sampleFileName = '';       // Name of loaded sample file
        let sampleDuration = 0;        // Duration in seconds

        // Master Volume control
        document.getElementById('masterVolume').addEventListener('input', (e) => {
            const vol = parseFloat(e.target.value);
            document.getElementById('masterVolumeValue').textContent = `${vol.toFixed(2)} (${(vol * 100).toFixed(0)}%)`;
        });
        
        // Sound Source mode toggle (Synthesizer vs Sampler)
        document.querySelectorAll('input[name="soundSource"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                samplerMode = e.target.value === 'sampler';
                const uploadSection = document.getElementById('sampleUploadSection');
                uploadSection.style.display = samplerMode ? 'block' : 'none';
                
                console.log(`üéõÔ∏è Switched to ${samplerMode ? 'SAMPLER' : 'SYNTHESIZER'} mode`);
                
                // Rebuild parameter UI and patch visualization with new parameter set
                if (numericPaths.length > 0) {
                    createMappingControls(numericPaths);
                    const nodes = createNodes(numericPaths);
                    drawNodes(document.getElementById('patchViz'));
                    console.log('‚úÖ UI rebuilt for new mode');
                }
            });
        });
        
        // Sample file upload handler
        document.getElementById('sampleFileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log(`üìÇ Loading sample: ${file.name} (${file.type || 'unknown type'})`);
            
            // Hide error, show loading state
            document.getElementById('sampleLoadError').style.display = 'none';
            document.getElementById('sampleInfo').style.display = 'none';
            
            // Check file extension for M4A warning
            const fileExt = file.name.split('.').pop().toLowerCase();
            const isM4A = fileExt === 'm4a' || file.type === 'audio/x-m4a' || file.type === 'audio/mp4';
            
            if (isM4A) {
                console.warn('‚ö†Ô∏è M4A format detected - browser support varies. If loading fails, please convert to WAV, MP3, or OGG.');
            }
            
            try {
                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();
                
                // Initialize audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Decode audio data
                sampleBuffer = await audioContext.decodeAudioData(arrayBuffer);
                sampleFileName = file.name;
                sampleDuration = sampleBuffer.duration;
                
                // Display sample info
                document.getElementById('sampleFileName').textContent = file.name;
                document.getElementById('sampleDuration').textContent = `${sampleDuration.toFixed(2)}s`;
                document.getElementById('sampleFormat').textContent = 
                    `${sampleBuffer.numberOfChannels} ch, ${(sampleBuffer.sampleRate / 1000).toFixed(1)} kHz`;
                document.getElementById('sampleInfo').style.display = 'block';
                
                console.log(`‚úÖ Sample loaded: ${sampleDuration.toFixed(2)}s, ${sampleBuffer.numberOfChannels}ch, ${sampleBuffer.sampleRate}Hz`);
                
            } catch (error) {
                console.error('‚ùå Error loading sample:', error);
                
                // Provide specific error message for M4A files
                let errorMsg = `Error loading sample: ${error.message}. `;
                
                if (isM4A) {
                    errorMsg = `‚ö†Ô∏è M4A format not supported by your browser's audio decoder. 

Please convert your audio file to one of these formats:
‚Ä¢ WAV (best compatibility, lossless)
‚Ä¢ MP3 (widely supported, smaller files)
‚Ä¢ OGG (good compression, open format)

Free online converters: CloudConvert.com, FreeConvert.com
Or use audio software like Audacity (free).`;
                } else {
                    errorMsg += `Please try WAV, MP3, or OGG format.`;
                }
                
                document.getElementById('sampleLoadError').textContent = errorMsg;
                document.getElementById('sampleLoadError').style.display = 'block';
                sampleBuffer = null;
            }
        });
        
        // Clear sample button
        document.getElementById('clearSampleBtn').addEventListener('click', () => {
            sampleBuffer = null;
            sampleFileName = '';
            sampleDuration = 0;
            document.getElementById('sampleFileInput').value = '';
            document.getElementById('sampleInfo').style.display = 'none';
            console.log('üóëÔ∏è Sample cleared');
        });
        
        // Speed control
        document.getElementById('speedControl').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = `${e.target.value}x`;
        });
        
        // Pitch control
        document.getElementById('pitchControl').addEventListener('input', (e) => {
            const semitones = parseFloat(e.target.value);
            const sign = semitones >= 0 ? '+' : '';
            document.getElementById('pitchValue').textContent = `${sign}${semitones.toFixed(1)} semitones`;
        });
        
        // Pitch quantization toggle - show/hide scale selector
        const pitchQuantCheckbox = document.getElementById('pitchQuantization');
        const scaleContainer = document.getElementById('scaleContainer');
        
        // Show scale selector if pitch quantization is checked on load
        if (pitchQuantCheckbox.checked) {
            scaleContainer.style.display = 'block';
        }
        
        pitchQuantCheckbox.addEventListener('change', (e) => {
            scaleContainer.style.display = e.target.checked ? 'block' : 'none';
        });

        // Custom sound generation functions
        function createNoiseBuffer(audioContext, type, duration) {
            const bufferSize = audioContext.sampleRate * (duration / 1000);
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            if (type === 'white-noise') {
                // White noise: equal power across all frequencies
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
            } else if (type === 'pink-noise') {
                // Pink noise: 1/f power spectrum (more bass)
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }
            } else if (type === 'brown-noise') {
                // Brown noise: 1/f¬≤ power spectrum (even more bass)
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5; // Compensate for volume loss
                }
            }
            
            return buffer;
        }
        
        function createCustomOscillator(audioContext, frequency, type, duration) {
            if (type === 'white-noise' || type === 'pink-noise' || type === 'brown-noise') {
                // Use buffer source for noise
                const source = audioContext.createBufferSource();
                source.buffer = createNoiseBuffer(audioContext, type, duration);
                source.loop = false;
                return source;
            } else if (type === 'fm') {
                // FM synthesis: carrier modulated by modulator
                const carrier = audioContext.createOscillator();
                const modulator = audioContext.createOscillator();
                const modulatorGain = audioContext.createGain();
                
                carrier.frequency.value = frequency;
                modulator.frequency.value = frequency * 2.5; // Harmonic ratio
                modulatorGain.gain.value = frequency * 0.8; // Modulation depth
                
                modulator.connect(modulatorGain);
                modulatorGain.connect(carrier.frequency);
                
                carrier.type = 'sine';
                modulator.type = 'sine';
                
                // Store modulator to start/stop together
                carrier._modulator = modulator;
                carrier._modulatorGain = modulatorGain;
                
                return carrier;
            } else if (type === 'additive') {
                // Additive synthesis: multiple harmonics
                // We'll return the fundamental and mix harmonics in manually
                const osc = audioContext.createOscillator();
                osc.frequency.value = frequency;
                osc.type = 'sine';
                osc._isAdditive = true;
                return osc;
            } else if (type === 'pwm') {
                // Pulse width modulation using square wave
                const osc = audioContext.createOscillator();
                osc.frequency.value = frequency;
                osc.type = 'square';
                osc._isPWM = true;
                return osc;
            } else {
                // Standard waveforms
                const osc = audioContext.createOscillator();
                osc.frequency.value = frequency;
                osc.type = type; // sine, square, sawtooth, triangle
                return osc;
            }
        }
        
        // Extract all paths from JSON - samples multiple items to find common paths
        function extractPaths(obj, prefix = '', depth = 0) {
            const paths = [];
            const maxDepth = 5; // Prevent infinite recursion
            
            if (depth > maxDepth) {
                return paths;
            }
            
            if (Array.isArray(obj)) {
                if (obj.length > 0) {
                    // Sample first item for structure
                    const sample = obj[0];
                    if (typeof sample === 'object' && sample !== null) {
                        const subPaths = extractPaths(sample, prefix, depth + 1);
                        
                        // For arrays, verify paths exist in multiple items
                        const verifiedPaths = subPaths.map(pathObj => {
                            // Count how many items have this path with a non-null value
                            let count = 0;
                            const sampleSize = Math.min(20, obj.length); // Sample more items
                            for (let i = 0; i < sampleSize; i++) {
                                const val = getValueByPath(obj[i], pathObj.path);
                                if (val !== undefined && val !== null) {
                                    count++;
                                }
                            }
                            
                            return {
                                ...pathObj,
                                coverage: count / sampleSize // % of items that have this field
                            };
                        });
                        
                        // Log filtered paths
                        const filtered = verifiedPaths.filter(p => p.coverage < 0.1);
                        if (filtered.length > 0) {
                            console.log('Filtered out sparse paths (<10% coverage):', filtered.map(p => `${p.path} (${(p.coverage * 100).toFixed(0)}%)`));
                        }
                        
                        // Only include paths that exist in at least 10% of sampled items (reduced from 30%)
                        paths.push(...verifiedPaths.filter(p => p.coverage >= 0.1));
                    } else {
                        paths.push({
                            path: prefix || 'root',
                            type: typeof sample,
                            isArray: true,
                            sample: obj.slice(0, 3),
                            coverage: 1.0
                        });
                    }
                }
            } else if (typeof obj === 'object' && obj !== null) {
                for (const key in obj) {
                    const fullPath = prefix ? `${prefix}.${key}` : key;
                    const value = obj[key];
                    
                    if (Array.isArray(value)) {
                        paths.push(...extractPaths(value, fullPath, depth + 1));
                    } else if (typeof value === 'object' && value !== null) {
                        paths.push(...extractPaths(value, fullPath, depth + 1));
                    } else {
                        paths.push({
                            path: fullPath,
                            type: typeof value,
                            isArray: false,
                            sample: value,
                            coverage: 1.0
                        });
                    }
                }
            }
            
            return paths;
        }

        // Get value from object using path (dot notation like "properties.mag")
        function getValueByPath(obj, path) {
            if (!obj || !path) return undefined;
            try {
                return path.split('.').reduce((curr, key) => {
                    if (curr === null || curr === undefined) return undefined;
                    return curr[key];
                }, obj);
            } catch (e) {
                console.warn(`Error accessing path ${path}:`, e);
                return undefined;
            }
        }
        
        // Convert path to CSS-safe ID (dots cause issues in selectors)
        // "properties.mag" ‚Üí "properties_mag"
        // "geometry.coordinates" ‚Üí "geometry_coordinates"
        function safeId(path) {
            return path.replace(/\./g, '_').replace(/[^a-zA-Z0-9_-]/g, '_');
        }

        // Extract values from array data
        function extractValues(data, path) {
            if (Array.isArray(data)) {
                return data.map(item => getValueByPath(item, path)).filter(v => v !== undefined);
            }
            return [getValueByPath(data, path)].filter(v => v !== undefined);
        }
        
        // Adaptive Range Normalization - auto-detect low variance and apply curve
        function analyzeDataVariance(values) {
            if (!values || values.length === 0) return { curve: 'linear', coefficient: 0 };
            
            const numericValues = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
            if (numericValues.length === 0) return { curve: 'linear', coefficient: 0 };
            
            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);
            const range = max - min;
            const mean = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            
            // Coefficient of variation (normalized variance)
            const coefficientOfVariation = Math.abs(mean) > 0 ? range / Math.abs(mean) : 0;
            
            let recommendedCurve = 'linear';
            
            // Very low variance (e.g., lat/lon: 39.28-39.29) = dramatic amplification
            if (coefficientOfVariation < 0.01) {
                recommendedCurve = 'cubic';
            } 
            // Low variance = moderate amplification
            else if (coefficientOfVariation < 0.1) {
                recommendedCurve = 'exponential';
            }
            // Very high variance = compress extremes
            else if (coefficientOfVariation > 5) {
                recommendedCurve = 'logarithmic';
            }
            
            return { curve: recommendedCurve, coefficient: coefficientOfVariation };
        }
        
        // Rhythmic Quantization - snap to musical grid
        function quantizeRhythm(spacing) {
            // Musical time divisions (in ms at 120 BPM)
            const rhythmGrid = [
                125,   // 32nd note
                250,   // 16th note
                375,   // Dotted 16th
                500,   // 8th note
                750,   // Dotted 8th
                1000,  // Quarter note
                1500,  // Dotted quarter
                2000   // Half note
            ];
            
            // Find nearest grid value
            return rhythmGrid.reduce((prev, curr) => 
                Math.abs(curr - spacing) < Math.abs(prev - spacing) ? curr : prev
            );
        }
        
        // Pitch Quantization - snap to musical scales
        function quantizePitch(frequency) {
            const scaleType = document.getElementById('scaleSelector')?.value || 'pentatonic';
            
            // Define scales as MIDI note offsets from C (within one octave)
            const scales = {
                pentatonic: [0, 2, 4, 7, 9], // C D E G A
                major: [0, 2, 4, 5, 7, 9, 11], // C D E F G A B
                minor: [0, 2, 3, 5, 7, 8, 10], // C D Eb F G Ab Bb
                dorian: [0, 2, 3, 5, 7, 9, 10], // C D Eb F G A Bb
                mixolydian: [0, 2, 4, 5, 7, 9, 10], // C D E F G A Bb
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] // All 12 notes
            };
            
            const scale = scales[scaleType] || scales.pentatonic;
            
            // Convert frequency to MIDI note number
            const midiNote = 69 + 12 * Math.log2(frequency / 440);
            
            // Find base octave and note within octave
            const octave = Math.floor(midiNote / 12);
            const noteInOctave = midiNote % 12;
            
            // Find closest scale degree
            let closestScaleDegree = scale[0];
            let minDistance = Math.abs(noteInOctave - closestScaleDegree);
            
            for (const degree of scale) {
                const distance = Math.abs(noteInOctave - degree);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestScaleDegree = degree;
                }
            }
            
            // Reconstruct MIDI note in scale
            const quantizedMidi = octave * 12 + closestScaleDegree;
            
            // Convert back to frequency
            const quantizedFrequency = 440 * Math.pow(2, (quantizedMidi - 69) / 12);
            
            return quantizedFrequency;
        }

        // Get audio parameters based on current mode (synthesizer vs sampler)
        function getAudioParams() {
            if (samplerMode) {
                // Sampler mode: pitch, sampleOffset, duration, effects
                return [
                    { id: 'pitch', label: 'Pitch (Playback Rate)', min: 0.25, max: 4, default: 1 },
                    { id: 'sampleOffset', label: 'Sample Start (0-1)', min: 0, max: 1, default: 0 },
                    { id: 'duration', label: 'Duration (ms)', min: 50, max: 2000, default: 200 },
                    { id: 'noteSpacing', label: 'Note Spacing (ms) - Rhythm', min: 50, max: 2000, default: 300 },
                    { id: 'pan', label: 'Pan', min: -1, max: 1, default: 0 },
                    { id: 'filterFreq', label: 'Filter Freq (Hz)', min: 200, max: 8000, default: 2000 },
                    { id: 'filterQ', label: 'Filter Q', min: 0.1, max: 20, default: 1 },
                    { id: 'delayTime', label: 'Delay Time (ms)', min: 50, max: 1000, default: 300 },
                    { id: 'delayFeedback', label: 'Delay Feedback', min: 0.1, max: 0.85, default: 0.5 },
                    { id: 'delayMix', label: 'Delay Mix', min: 0.1, max: 0.9, default: 0.5 },
                    { id: 'reverbDecay', label: 'Reverb Decay (s)', min: 0.1, max: 10, default: 2 },
                    { id: 'reverbMix', label: 'Reverb Mix', min: 0, max: 1, default: 0.3 },
                    { id: 'attack', label: 'Attack (ms)', min: 1, max: 1000, default: 10 },
                    { id: 'release', label: 'Release (ms)', min: 1, max: 2000, default: 100 }
                ];
            } else {
                // Synthesizer mode: frequency, duration, effects
                return [
                    { id: 'frequency', label: 'Frequency (Hz)', min: 200, max: 2000, default: 440 },
                    { id: 'duration', label: 'Duration (ms)', min: 50, max: 2000, default: 200 },
                    { id: 'noteSpacing', label: 'Note Spacing (ms) - Rhythm', min: 50, max: 2000, default: 300 },
                    { id: 'pan', label: 'Pan', min: -1, max: 1, default: 0 },
                    { id: 'filterFreq', label: 'Filter Freq (Hz)', min: 200, max: 8000, default: 2000 },
                    { id: 'filterQ', label: 'Filter Q', min: 0.1, max: 20, default: 1 },
                    { id: 'delayTime', label: 'Delay Time (ms)', min: 50, max: 1000, default: 300 },
                    { id: 'delayFeedback', label: 'Delay Feedback', min: 0.1, max: 0.85, default: 0.5 },
                    { id: 'delayMix', label: 'Delay Mix', min: 0.1, max: 0.9, default: 0.5 },
                    { id: 'reverbDecay', label: 'Reverb Decay (s)', min: 0.1, max: 10, default: 2 },
                    { id: 'reverbMix', label: 'Reverb Mix', min: 0, max: 1, default: 0.3 },
                    { id: 'attack', label: 'Attack (ms)', min: 1, max: 1000, default: 10 },
                    { id: 'release', label: 'Release (ms)', min: 1, max: 2000, default: 100 }
                ];
            }
        }
        
        // Create mapping controls
        function createMappingControls(numericPaths) {
            const mappingControls = document.getElementById('mappingControls');
            mappingControls.innerHTML = '';
            
            const audioParams = getAudioParams();
            
            audioParams.forEach(param => {
                const div = document.createElement('div');
                div.className = 'bg-black-05 pa2';
                div.innerHTML = `
                    <div class="b mb2 f6">${param.label}</div>
                    <label class="db mb2">
                        <span class="db mb1">Path:</span>
                        <select id="map_${param.id}" class="w-100 pa1 ba b--black-20 f6">
                            <option value="">-- Fixed --</option>
                            ${numericPaths.map(p => `<option value="${p.path}">${p.path}</option>`).join('')}
                        </select>
                    </label>
                    <div class="flex items-center mb2">
                        <label class="mr2 flex-auto">
                            <span class="db mb1">Fixed:</span>
                            <input type="number" id="fixed_${param.id}" value="${param.default}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                        <label class="mr2 flex-auto">
                            <span class="db mb1">Min:</span>
                            <input type="number" id="min_${param.id}" value="${param.min}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                        <label class="flex-auto">
                            <span class="db mb1">Max:</span>
                            <input type="number" id="max_${param.id}" value="${param.max}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                    </div>
                    <label class="db">
                        <span class="db mb1">Curve:</span>
                        <select id="curve_${param.id}" class="w-100 pa1 ba b--black-20 f6">
                            <option value="linear">Linear</option>
                            <option value="exponential">Exponential</option>
                            <option value="cubic">Cubic</option>
                            <option value="logarithmic">Logarithmic</option>
                            <option value="inverse">Inverse</option>
                        </select>
                    </label>
                `;
                mappingControls.appendChild(div);
                
                mappings[param.id] = {
                    path: '',
                    fixed: param.default,
                    min: param.min,
                    max: param.max,
                    curve: 'linear'
                };
                
                document.getElementById(`map_${param.id}`).addEventListener('change', (e) => {
                    mappings[param.id].path = e.target.value;
                    updatePatchVisualization();
                });
                
                document.getElementById(`fixed_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].fixed = parseFloat(e.target.value);
                });
                
                document.getElementById(`min_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].min = parseFloat(e.target.value);
                });
                
                document.getElementById(`max_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].max = parseFloat(e.target.value);
                });
                
                document.getElementById(`curve_${param.id}`).addEventListener('change', (e) => {
                    mappings[param.id].curve = e.target.value;
                });
            });
            
            updatePatchVisualization();
        }

        // Intelligent Mapping - analyzes data and creates musically interesting mappings
        function intelligentMapping() {
            if (Object.keys(mappings).length === 0 || numericPaths.length === 0) {
                console.warn('No mappings or paths available');
                return;
            }
            
            console.log('=== Smart Mapping ===');
            
            const dataArray = Array.isArray(parsedData) ? parsedData : [parsedData];
            
            // Analyze each path for "interestingness"
            const pathAnalysis = numericPaths.map(pathObj => {
                const values = extractValues(dataArray, pathObj.path);
                const numericValues = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
                
                if (numericValues.length === 0) return null;
                
                const min = Math.min(...numericValues);
                const max = Math.max(...numericValues);
                const range = max - min;
                const mean = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
                const variance = numericValues.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / numericValues.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = Math.abs(mean) > 0 ? stdDev / Math.abs(mean) : 0;
                
                // Calculate unique value ratio
                const uniqueValues = new Set(numericValues).size;
                const uniqueRatio = uniqueValues / numericValues.length;
                
                // Interest score: higher variance + more unique values = more interesting
                const interestScore = coefficientOfVariation * uniqueRatio * Math.log10(range + 1);
                
                return {
                    path: pathObj.path,
                    min,
                    max,
                    range,
                    coefficientOfVariation,
                    uniqueRatio,
                    interestScore,
                    values: numericValues
                };
            }).filter(x => x !== null);
            
            // Sort by interest score (most interesting first)
            pathAnalysis.sort((a, b) => b.interestScore - a.interestScore);
            
            console.log('Path analysis (sorted by interest):');
            pathAnalysis.forEach(p => {
                console.log(`  ${p.path}: score=${p.interestScore.toFixed(3)}, CV=${p.coefficientOfVariation.toFixed(3)}, unique=${(p.uniqueRatio*100).toFixed(0)}%`);
            });
            
            // Define parameter importance (perceptual impact) - mode-specific
            const parameterTiers = samplerMode ? {
                critical: ['noteSpacing', 'sampleOffset', 'duration'], // Rhythm and sample position for variation
                important: ['pitch', 'pan', 'delayTime', 'delayFeedback', 'delayMix', 'attack', 'release'], // Clear impact
                subtle: ['filterFreq', 'filterQ', 'reverbDecay', 'reverbMix'] // Textural
            } : {
                critical: ['noteSpacing', 'frequency', 'duration'], // Rhythm first for more interesting patterns
                important: ['pan', 'filterFreq', 'delayTime', 'delayFeedback', 'delayMix', 'attack', 'release'], // Clear impact (delay elevated for sonic interest)
                subtle: ['filterQ', 'reverbDecay', 'reverbMix'] // Textural
            };
            
            // Clear all mappings first
            Object.keys(mappings).forEach(param => {
                mappings[param].path = '';
                const mapEl = document.getElementById(`map_${param}`);
                if (mapEl) mapEl.value = '';
            });
            
            let pathIndex = 0;
            
            // Map most interesting data to critical parameters
            parameterTiers.critical.forEach(param => {
                if (pathIndex < pathAnalysis.length && mappings[param]) {
                    const pathData = pathAnalysis[pathIndex];
                    mappings[param].path = pathData.path;
                    
                    // Set musically interesting ranges
                    if (param === 'frequency') {
                        // Use pentatonic scale frequencies for guaranteed consonance
                        const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00];
                        mappings[param].min = pentatonic[0];
                        mappings[param].max = pentatonic[pentatonic.length - 1];
                    } else if (param === 'duration') {
                        mappings[param].min = 100;
                        mappings[param].max = 600;
                    } else if (param === 'noteSpacing') {
                        // Wider range for more dramatic rhythmic variation (fast staccato to slow spacious)
                        mappings[param].min = 80;   // Rapid-fire notes
                        mappings[param].max = 1200; // Spacious, meditative gaps
                    }
                    
                    // Apply appropriate curve based on variance
                    if (param === 'noteSpacing') {
                        // Special curve handling for rhythm - exponential creates accelerando/ritardando feel
                        if (pathData.coefficientOfVariation < 0.01) {
                            mappings[param].curve = 'cubic'; // Amplify tiny differences for subtle rhythmic shifts
                        } else if (pathData.coefficientOfVariation < 0.5) {
                            mappings[param].curve = 'exponential'; // Most dramatic rhythmic acceleration
                        } else if (pathData.coefficientOfVariation > 3) {
                            mappings[param].curve = 'logarithmic'; // Compress extreme values for controlled variation
                        } else {
                            mappings[param].curve = 'exponential'; // Default to exponential for interesting rhythm
                        }
                    } else if (pathData.coefficientOfVariation < 0.01) {
                        mappings[param].curve = 'cubic'; // Amplify tiny differences
                    } else if (pathData.coefficientOfVariation < 0.1) {
                        mappings[param].curve = 'exponential';
                    } else if (pathData.coefficientOfVariation > 5) {
                        mappings[param].curve = 'logarithmic'; // Compress extremes
                    } else {
                        mappings[param].curve = 'linear';
                    }
                    
                    // Update UI
                    const mapEl = document.getElementById(`map_${param}`);
                    const minEl = document.getElementById(`min_${param}`);
                    const maxEl = document.getElementById(`max_${param}`);
                    const curveEl = document.getElementById(`curve_${param}`);
                    
                    if (mapEl) mapEl.value = pathData.path;
                    if (minEl) minEl.value = mappings[param].min;
                    if (maxEl) maxEl.value = mappings[param].max;
                    if (curveEl) curveEl.value = mappings[param].curve;
                    
                    if (param === 'noteSpacing') {
                        console.log(`üéµ Mapped ${pathData.path} ‚Üí ${param} (${mappings[param].curve}) [RHYTHM: ${mappings[param].min}-${mappings[param].max}ms]`);
                    } else {
                        console.log(`‚úì Mapped ${pathData.path} ‚Üí ${param} (${mappings[param].curve})`);
                    }
                    pathIndex++;
                }
            });
            
            // Map remaining interesting data to important parameters
            parameterTiers.important.forEach(param => {
                if (pathIndex < pathAnalysis.length && mappings[param]) {
                    const pathData = pathAnalysis[pathIndex];
                    mappings[param].path = pathData.path;
                    
                    // Set ranges for maximum impact
                    if (param === 'pan') {
                        mappings[param].min = -1;
                        mappings[param].max = 1;
                    } else if (param === 'filterFreq') {
                        mappings[param].min = 400;
                        mappings[param].max = 8000;
                    } else if (param === 'attack') {
                        mappings[param].min = 5;
                        mappings[param].max = 300;
                    } else if (param === 'release') {
                        mappings[param].min = 50;
                        mappings[param].max = 800;
                    }
                    
                    // Smart curve selection
                    if (pathData.coefficientOfVariation < 0.05) {
                        mappings[param].curve = 'exponential';
                    } else {
                        mappings[param].curve = 'linear';
                    }
                    
                    // Update UI
                    const mapEl = document.getElementById(`map_${param}`);
                    const minEl = document.getElementById(`min_${param}`);
                    const maxEl = document.getElementById(`max_${param}`);
                    const curveEl = document.getElementById(`curve_${param}`);
                    
                    if (mapEl) mapEl.value = pathData.path;
                    if (minEl) minEl.value = mappings[param].min;
                    if (maxEl) maxEl.value = mappings[param].max;
                    if (curveEl) curveEl.value = mappings[param].curve;
                    
                    console.log(`‚úì Mapped ${pathData.path} ‚Üí ${param} (${mappings[param].curve})`);
                    pathIndex++;
                }
            });
            
            // Map extra data to subtle parameters (all delay params now mapped for dynamic sonic variation)
            const extraPaths = pathAnalysis.slice(pathIndex);
            if (extraPaths.length > 0) {
                // Map all 3 delay parameters with aggressive ranges for varied delay textures
                const delayParams = [
                    { 
                        id: 'delayTime', 
                        min: 50,    // Short slapback
                        max: 800,   // Long echo
                        curve: 'linear',
                        description: 'wide timing variation'
                    },
                    { 
                        id: 'delayFeedback', 
                        min: 0.1,   // Subtle single repeat
                        max: 0.8,   // Building repeats
                        curve: 'exponential',
                        description: 'feedback dynamics'
                    },
                    { 
                        id: 'delayMix', 
                        min: 0.2,   // Subtle presence
                        max: 0.8,   // Prominent delay
                        curve: 'linear',
                        description: 'wet/dry balance'
                    }
                ];
                
                delayParams.forEach((delayParam, idx) => {
                    if (extraPaths.length > idx && mappings[delayParam.id]) {
                        const pathData = extraPaths[idx];
                        mappings[delayParam.id].path = pathData.path;
                        mappings[delayParam.id].min = delayParam.min;
                        mappings[delayParam.id].max = delayParam.max;
                        mappings[delayParam.id].curve = delayParam.curve;
                        
                        const mapEl = document.getElementById(`map_${delayParam.id}`);
                        const minEl = document.getElementById(`min_${delayParam.id}`);
                        const maxEl = document.getElementById(`max_${delayParam.id}`);
                        const curveEl = document.getElementById(`curve_${delayParam.id}`);
                        
                        if (mapEl) mapEl.value = pathData.path;
                        if (minEl) minEl.value = delayParam.min;
                        if (maxEl) maxEl.value = delayParam.max;
                        if (curveEl) curveEl.value = delayParam.curve;
                        
                        console.log(`‚úì Mapped ${pathData.path} ‚Üí ${delayParam.id} (${delayParam.description})`);
                    }
                });
            }
            
            // Set interesting waveform and filter
            const interestingWaveforms = ['sawtooth', 'square', 'triangle']; // More character than sine
            const randomWaveform = interestingWaveforms[Math.floor(Math.random() * interestingWaveforms.length)];
            const waveformEl = document.querySelector(`input[name="waveform"][value="${randomWaveform}"]`);
            if (waveformEl) waveformEl.checked = true;
            
            const filterTypes = ['lowpass', 'bandpass', 'highpass'];
            const randomFilter = filterTypes[Math.floor(Math.random() * filterTypes.length)];
            const filterEl = document.querySelector(`input[name="filterType"][value="${randomFilter}"]`);
            if (filterEl) filterEl.checked = true;
            
            console.log(`Set waveform: ${randomWaveform}, filter: ${randomFilter}`);
            
            // Verify noteSpacing is mapped for rhythmic variation
            if (!mappings['noteSpacing']?.path) {
                console.warn('‚ö†Ô∏è NOTE SPACING NOT MAPPED - Will use automatic variation (¬±20% random)');
                console.warn('   For best results, map noteSpacing to a data field for rhythmic patterns');
            } else {
                console.log('‚úÖ Note spacing mapped to data - rhythmic variation enabled');
            }
            
            console.log('=== Smart Mapping Complete ===');
            
            updatePatchVisualization();
        }

        // Randomization
        function randomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function randomizeMappings() {
            if (Object.keys(mappings).length === 0) {
                console.warn('No mappings to randomize');
                return;
            }
            
            console.log('Randomizing mappings...');
            
            const curves = ['linear', 'exponential', 'cubic', 'logarithmic', 'inverse'];
            let mappedCount = 0;
            
            Object.keys(mappings).forEach(paramId => {
                // noteSpacing always gets mapped for rhythmic interest; others 70% of the time
                const shouldMap = paramId === 'noteSpacing' ? true : (Math.random() > 0.3);
                
                if (shouldMap && numericPaths.length > 0) {
                    const randomPath = randomElement(numericPaths).path;
                    const mapEl = document.getElementById(`map_${paramId}`);
                    if (mapEl) mapEl.value = randomPath;
                    mappings[paramId].path = randomPath;
                    
                    // noteSpacing favors exponential curves for dramatic rhythm
                    let randomCurve;
                    if (paramId === 'noteSpacing') {
                        randomCurve = Math.random() < 0.6 ? 'exponential' : randomElement(curves);
                    } else {
                        randomCurve = Math.random() < 0.5 ? 'linear' : randomElement(curves);
                    }
                    
                    const curveEl = document.getElementById(`curve_${paramId}`);
                    if (curveEl) curveEl.value = randomCurve;
                    mappings[paramId].curve = randomCurve;
                    
                    mappedCount++;
                } else {
                    const mapEl = document.getElementById(`map_${paramId}`);
                    if (mapEl) mapEl.value = '';
                    mappings[paramId].path = '';
                }
            });
            
            console.log(`Mapped ${mappedCount} parameters`);
            
            const waveformEl = document.querySelector(`input[name="waveform"]`);
            if (waveformEl) {
                const waveforms = ['sine', 'square', 'sawtooth', 'triangle'];
                const selected = document.querySelector(`input[name="waveform"][value="${randomElement(waveforms)}"]`);
                if (selected) selected.checked = true;
            }
            
            const filterEl = document.querySelector(`input[name="filterType"]`);
            if (filterEl) {
                const filterTypes = ['lowpass', 'highpass', 'bandpass', 'notch'];
                const selected = document.querySelector(`input[name="filterType"][value="${randomElement(filterTypes)}"]`);
                if (selected) selected.checked = true;
            }
            
            updatePatchVisualization();
        }

        function randomizeRanges() {
            Object.keys(mappings).forEach(paramId => {
                const mapping = mappings[paramId];
                if (!mapping) return;
                
                const range = mapping.max - mapping.min;
                const newMin = mapping.min + (Math.random() - 0.1) * range * 0.3;
                const newMax = mapping.max + (Math.random() - 0.1) * range * 0.5;
                const actualMin = Math.min(newMin, newMax);
                const actualMax = Math.max(newMin, newMax);
                
                const minEl = document.getElementById(`min_${paramId}`);
                if (minEl) minEl.value = actualMin.toFixed(2);
                
                const maxEl = document.getElementById(`max_${paramId}`);
                if (maxEl) maxEl.value = actualMax.toFixed(2);
                
                mappings[paramId].min = actualMin;
                mappings[paramId].max = actualMax;
            });
        }

        function randomizeAll() {
            randomizeMappings();
            randomizeRanges();
        }

        document.getElementById('randomizeMappingsBtn').addEventListener('click', randomizeMappings);
        document.getElementById('randomizeMappingsBtn2')?.addEventListener('click', randomizeMappings);
        document.getElementById('randomizeRangesBtn')?.addEventListener('click', randomizeRanges);
        document.getElementById('randomizeAllBtn')?.addEventListener('click', randomizeAll);

        // Node-based patch visualization
        let nodes = [];
        let selectedSourceNode = null;
        let currentEditingConnection = null;
        let zoomBehavior;
        let currentTransform = d3.zoomIdentity;
        
        function updatePatchVisualization() {
            const svg = d3.select('#patchViz');
            if (svg.empty()) {
                console.warn('patchViz SVG element not found');
                return;
            }
            
            svg.selectAll('*').remove();
            
            const width = parseInt(svg.style('width')) || 800;
            
            if (numericPaths.length === 0) {
                svg.attr('height', 200);
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', 100)
                    .attr('text-anchor', 'middle')
                    .attr('class', 'node-text')
                    .text('Parse JSON/CSV to see data nodes');
                return;
            }
            
            // Always recreate nodes to handle data changes
            nodes = []; // Reset nodes
            createNodes();
            
            console.log(`Creating visualization with ${nodes.length} nodes`);
            
            // Calculate height based on number of nodes
            const nodeSpacing = 45;
            const dataNodeCount = nodes.filter(n => n.type === 'data').length;
            const audioNodeCount = nodes.filter(n => n.type === 'audio').length;
            const maxNodes = Math.max(dataNodeCount, audioNodeCount);
            const dynamicHeight = 30 + (maxNodes * nodeSpacing) + 30; // Top padding + nodes + bottom padding
            
            svg.attr('height', dynamicHeight);
            console.log(`SVG height set to ${dynamicHeight}px for ${maxNodes} nodes`);
            
            // Create main group (no zoom/pan - fixed layout)
            const g = svg.append('g').attr('class', 'main-group');
            
            // Draw connections first (behind nodes)
            const connectionGroup = g.append('g').attr('class', 'connections');
            updateConnections(connectionGroup);
            
            // Draw nodes
            const nodeGroup = g.append('g').attr('class', 'nodes');
            drawNodes(nodeGroup);
        }
        
        function createNodes() {
            nodes = [];
            const svg = d3.select('#patchViz');
            const svgWidth = parseInt(svg.style('width')) || 600;
            
            const nodeSpacing = 50; // More padding per node
            
            // Responsive margins and column positioning
            const margin = svgWidth < 600 ? 40 : 100; // Smaller margins on mobile
            const columnGap = (svgWidth - (2 * margin)) * 0.25; // 50% closer together
            const leftX = margin + columnGap;
            const rightX = svgWidth - margin - columnGap;
            
            console.log(`Node layout: width=${svgWidth}, margin=${margin}, gap=${columnGap.toFixed(0)}, leftX=${leftX.toFixed(0)}, rightX=${rightX.toFixed(0)}`);
            
            // Update column headers to match node positions
            const leftHeaderEl = document.getElementById('leftHeader');
            const rightHeaderEl = document.getElementById('rightHeader');
            if (leftHeaderEl) leftHeaderEl.style.left = `${leftX}px`;
            if (rightHeaderEl) rightHeaderEl.style.left = `${rightX}px`;
            
            // Data nodes (left side) - compact layout
            // NOTE: Using safeId() to convert paths like "properties.mag" to CSS-safe IDs
            numericPaths.forEach((path, i) => {
                nodes.push({
                    id: `data_${safeId(path.path)}`,  // CSS-safe ID: properties.mag ‚Üí data_properties_mag
                    label: path.path,                  // Display original path with dots
                    x: leftX,
                    y: 30 + i * nodeSpacing,
                    type: 'data',
                    dataPath: path.path                // Store original path for data lookup
                });
            });
            
            // Audio parameter nodes (right side) - dynamically based on mode
            const audioParamsConfig = getAudioParams();
            const audioParams = audioParamsConfig.map(p => p.id);
            
            audioParams.forEach((param, i) => {
                nodes.push({
                    id: `audio_${param}`,              // Already CSS-safe (no dots)
                    label: param,
                    x: rightX,
                    y: 30 + i * nodeSpacing,
                    type: 'audio',
                    audioParam: param
                });
            });
        }
        
        function drawNodes(container) {
            // Responsive node sizing - DATA NODES ARE WIDER
            const svg = d3.select('#patchViz');
            const svgWidth = parseInt(svg.style('width')) || 600;
            const audioNodeWidth = svgWidth < 600 ? 90 : 110; // Audio params stay compact
            const dataNodeWidth = svgWidth < 600 ? 120 : 160; // Data fields are wider
            const nodeHeight = svgWidth < 600 ? 32 : 36;
            
            // Helper function to truncate text
            const truncateText = (text, maxLength) => {
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength - 1) + '‚Ä¶';
            };
            
            const nodeGroups = container.selectAll('.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            // Node rectangle - different width for data vs audio
            nodeGroups.append('rect')
                .attr('class', 'node-rect')
                .attr('x', d => {
                    const width = d.type === 'data' ? dataNodeWidth : audioNodeWidth;
                    return -width/2;
                })
                .attr('y', -nodeHeight/2)
                .attr('width', d => d.type === 'data' ? dataNodeWidth : audioNodeWidth)
                .attr('height', nodeHeight)
                .attr('rx', 2)
                .attr('data-node-id', d => d.id);
            
            // Node label (truncate long data paths)
            nodeGroups.append('text')
                .attr('class', 'node-text')
                .attr('y', 0)
                .text(d => {
                    // Truncate data field labels to fit in wider boxes
                    const maxChars = d.type === 'data' ? 22 : 15;
                    return truncateText(d.label, maxChars);
                });
            
            // Value display (below label)
            // ID uses safe version: value_data_properties_mag (no dots)
            nodeGroups.append('text')
                .attr('class', 'node-value')
                .attr('id', d => `value_${d.id}`)  // d.id already CSS-safe from createNodes()
                .attr('y', 12)
                .attr('text-anchor', 'middle')
                .text('--');
            
            // Connection ports - positioned at edge of appropriate width node
            nodeGroups.append('circle')
                .attr('class', 'port')
                .attr('cx', d => {
                    const width = d.type === 'data' ? dataNodeWidth : audioNodeWidth;
                    return d.type === 'data' ? width/2 : -width/2;
                })
                .attr('cy', 0)
                .attr('r', 4)
                .on('click', function(event, d) {
                    event.stopPropagation();
                    handlePortClick(d);
                });
        }
        
        
        function handlePortClick(node) {
            if (node.type === 'data') {
                // Select as source
                if (selectedSourceNode) {
                    // Deselect previous
                    d3.selectAll('.node-rect').classed('selected', false);
                }
                selectedSourceNode = node;
                d3.select(`[data-node-id="${node.id}"]`).classed('selected', true);
            } else if (node.type === 'audio' && selectedSourceNode) {
                // Create connection
                const audioParam = node.audioParam;
                const dataPath = selectedSourceNode.dataPath;
                
                // Update mappings
                if (mappings[audioParam]) {
                    mappings[audioParam].path = dataPath;
                    
                    // Update form if in form view
                    const selectEl = document.getElementById(`map_${audioParam}`);
                    if (selectEl) {
                        selectEl.value = dataPath;
                    }
                }
                
                // Deselect
                d3.selectAll('.node-rect').classed('selected', false);
                selectedSourceNode = null;
                
                // Redraw
                updateConnections(d3.select('.connections'));
            }
        }
        
        function updateConnections(container) {
            if (!container) {
                console.warn('updateConnections: container is null');
                return;
            }
            container.selectAll('*').remove();
            
            // Get SVG width for responsive node sizing
            const svg = d3.select('#patchViz');
            const svgWidth = parseInt(svg.style('width')) || 600;
            const audioNodeWidth = svgWidth < 600 ? 90 : 110;
            const dataNodeWidth = svgWidth < 600 ? 120 : 160;
            let connectionCount = 0;
            
            // Draw each active mapping
            Object.entries(mappings).forEach(([audioParam, mapping]) => {
                if (mapping && mapping.path) {
                    const sourceNode = nodes.find(n => n.dataPath === mapping.path);
                    const targetNode = nodes.find(n => n.audioParam === audioParam);
                    
                    if (sourceNode && targetNode) {
                        // Use correct widths - data nodes are wider
                        const sourceX = sourceNode.x + dataNodeWidth/2;
                        const sourceY = sourceNode.y;
                        const targetX = targetNode.x - audioNodeWidth/2;
                        const targetY = targetNode.y;
                        const midX = (sourceX + targetX) / 2;
                        
                        const path = container.append('path')
                            .attr('class', 'connection-path')
                            .attr('d', `M ${sourceX},${sourceY} C ${midX},${sourceY} ${midX},${targetY} ${targetX},${targetY}`)
                            .datum({ source: mapping.path, target: audioParam })
                            .on('click', function(event) {
                                event.stopPropagation();
                                openConnectionEditor(audioParam, mapping);
                            });
                        
                        connectionCount++;
                    } else {
                        console.warn(`Connection ${audioParam} ‚Üí ${mapping.path}: missing nodes`, {
                            sourceFound: !!sourceNode,
                            targetFound: !!targetNode
                        });
                    }
                }
            });
            
            console.log(`Drew ${connectionCount} connections`);
        }
        
        // Connection editor
        function openConnectionEditor(audioParam, mapping) {
            currentEditingConnection = audioParam;
            
            document.getElementById('editorSource').textContent = mapping.path;
            document.getElementById('editorTarget').textContent = audioParam;
            document.getElementById('editorMin').value = mapping.min;
            document.getElementById('editorMax').value = mapping.max;
            document.getElementById('editorCurve').value = mapping.curve || 'linear';
            
            document.getElementById('connectionEditor').classList.add('active');
            document.getElementById('editorOverlay').classList.add('active');
        }
        
        function closeConnectionEditor() {
            if (currentEditingConnection) {
                // Save changes
                const param = currentEditingConnection;
                mappings[param].min = parseFloat(document.getElementById('editorMin').value);
                mappings[param].max = parseFloat(document.getElementById('editorMax').value);
                mappings[param].curve = document.getElementById('editorCurve').value;
                
                // Update form if exists
                const minEl = document.getElementById(`min_${param}`);
                const maxEl = document.getElementById(`max_${param}`);
                const curveEl = document.getElementById(`curve_${param}`);
                if (minEl) minEl.value = mappings[param].min;
                if (maxEl) maxEl.value = mappings[param].max;
                if (curveEl) curveEl.value = mappings[param].curve;
            }
            
            document.getElementById('connectionEditor').classList.remove('active');
            document.getElementById('editorOverlay').classList.remove('active');
            currentEditingConnection = null;
        }
        
        function deleteConnection() {
            if (currentEditingConnection) {
                mappings[currentEditingConnection].path = '';
                
                // Update form if exists
                const selectEl = document.getElementById(`map_${currentEditingConnection}`);
                if (selectEl) selectEl.value = '';
                
                closeConnectionEditor();
                updateConnections(d3.select('.connections'));
            }
        }
        
        document.getElementById('editorClose').addEventListener('click', closeConnectionEditor);
        document.getElementById('editorDelete').addEventListener('click', deleteConnection);
        document.getElementById('editorOverlay').addEventListener('click', closeConnectionEditor);
        
        // Clear all connections
        document.getElementById('clearPatchBtn')?.addEventListener('click', () => {
            Object.keys(mappings).forEach(param => {
                mappings[param].path = '';
                const selectEl = document.getElementById(`map_${param}`);
                if (selectEl) selectEl.value = '';
            });
            updateConnections(d3.select('.connections'));
        });
        
        
        // Update node visualization during playback
        // This function is called for each data item during sonification
        function updateNodeValues(currentItem, calculatedAudioParams) {
            // Clear previous highlights
            d3.selectAll('.node-rect').classed('playing', false);
            d3.selectAll('.connection-path').classed('active', false);
            
            // Debug: log current item structure once
            if (!window._loggedItemStructure) {
                console.log('=== Current Item Structure ===');
                console.log('Item:', currentItem);
                console.log('Item keys:', Object.keys(currentItem || {}));
                console.log('=== Node IDs for debugging ===');
                nodes.filter(n => n.type === 'data').slice(0, 3).forEach(n => {
                    console.log(`  ${n.label} ‚Üí ID: ${n.id} ‚Üí Element: #value_${n.id}`);
                });
                window._loggedItemStructure = true;
            }
            
            // Update data node values (left side nodes)
            nodes.forEach(node => {
                if (node.type === 'data') {
                    // Get value from current item using original path (with dots)
                    const value = getValueByPath(currentItem, node.dataPath);
                    
                    // Select DOM element using CSS-safe ID (no dots)
                    // node.id is already safe: "data_properties_mag" not "data_properties.mag"
                    const selector = `#value_${node.id}`;
                    const valueEl = document.getElementById(`value_${node.id}`);
                    
                    if (valueEl) {
                        if (value !== undefined && value !== null) {
                            const displayValue = typeof value === 'number' ? 
                                (Math.abs(value) < 0.01 ? value.toExponential(1) : value.toFixed(2)) : 
                                (String(value).length > 12 ? String(value).substring(0, 12) + '...' : value);
                            valueEl.textContent = displayValue;  // Direct DOM manipulation (faster than D3)
                        } else {
                            valueEl.textContent = '--';
                            // Debug: log missing values
                            if (!window._loggedMissingPaths) {
                                window._loggedMissingPaths = {};
                            }
                            if (!window._loggedMissingPaths[node.dataPath]) {
                                console.warn(`Cannot find value for path: ${node.dataPath} in item:`, currentItem);
                                window._loggedMissingPaths[node.dataPath] = true;
                            }
                        }
                        
                        // Highlight node if this data path is currently mapped
                        const isActive = Object.values(mappings).some(m => m.path === node.dataPath);
                        if (isActive) {
                            d3.select(`[data-node-id="${node.id}"]`).classed('playing', true);
                        }
                    } else {
                        // This should never happen if nodes are created correctly
                        if (!window._loggedMissingElements) {
                            window._loggedMissingElements = {};
                        }
                        if (!window._loggedMissingElements[node.id]) {
                            console.error(`Cannot find DOM element for node ID: ${node.id} (path: ${node.dataPath})`);
                            window._loggedMissingElements[node.id] = true;
                        }
                    }
                }
            });
            
            // Update audio param values (right side nodes)
            Object.entries(calculatedAudioParams).forEach(([param, value]) => {
                const node = nodes.find(n => n.audioParam === param);
                if (node && value !== undefined && value !== null) {
                    const displayValue = typeof value === 'number' ? 
                        (Math.abs(value) < 0.01 ? value.toExponential(1) : value.toFixed(2)) : 
                        (String(value).length > 12 ? String(value).substring(0, 12) + '...' : value);
                    
                    const valueEl = document.getElementById(`value_${node.id}`);
                    if (valueEl) {
                        valueEl.textContent = displayValue;  // Direct DOM manipulation
                    }
                    
                    // Highlight if mapped
                    if (mappings[param]?.path) {
                        d3.select(`[data-node-id="${node.id}"]`).classed('playing', true);
                        
                        // Highlight connection
                        const connPath = d3.selectAll('.connection-path')
                            .filter(function() {
                                return this.__data__?.target === param;
                            });
                        connPath.classed('active', true);
                    }
                }
            });
        }
        
        // Clear all node values
        function clearNodeValues() {
            d3.selectAll('.node-value').text('--');
            d3.selectAll('.node-rect').classed('playing', false);
            d3.selectAll('.connection-path').classed('active', false);
        }

        // Create impulse response for reverb
        function createReverbImpulse(duration, decay) {
            if (!audioContext) return null;
            
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                }
            }
            return impulse;
        }
        
        // Initialize global effects chain
        function initEffects() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Delay setup
            delayNode = audioContext.createDelay(2.0);
            delayFeedbackGain = audioContext.createGain();
            delayWetGain = audioContext.createGain();
            delayDryGain = audioContext.createGain();
            
            delayNode.connect(delayFeedbackGain);
            delayFeedbackGain.connect(delayNode);
            delayNode.connect(delayWetGain);
            
            // Reverb setup
            reverbNode = audioContext.createConvolver();
            reverbNode.buffer = createReverbImpulse(2, 2);
            reverbWetGain = audioContext.createGain();
            reverbDryGain = audioContext.createGain();
            
            reverbNode.connect(reverbWetGain);
            
            // Connect effects chain to destination
            delayWetGain.connect(reverbNode);
            delayWetGain.connect(reverbDryGain);
            delayDryGain.connect(reverbNode);
            delayDryGain.connect(audioContext.destination);
            reverbWetGain.connect(audioContext.destination);
        }
        
        // Audio visualizer
        const visualizerCanvas = document.getElementById('audioVisualizer');
        const visualizerCtx = visualizerCanvas.getContext('2d');
        let analyser, dataArray, animationId;

        function setupVisualizer() {
            if (!audioContext) return;
            
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256; // SMALLER FFT = lower latency, faster response
            analyser.smoothingTimeConstant = 0; // NO SMOOTHING = instant response
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            console.log('‚úÖ Visualizer: LOW LATENCY mode, buffer =', bufferLength);
            
            // Connect analyser to the end of effects chain
            reverbWetGain.connect(analyser);
            analyser.connect(audioContext.destination);
            
            // Set canvas size - make it taller for more visual impact
            visualizerCanvas.width = visualizerCanvas.offsetWidth;
            visualizerCanvas.height = 60; // Increased from 40 for more amplitude
            
            console.log('‚úÖ Canvas:', visualizerCanvas.width, 'x', visualizerCanvas.height, 'px');
        }

        function drawVisualizer() {
            if (!isPlaying) return;
            
            animationId = requestAnimationFrame(drawVisualizer);
            
            // Get frequency data (spectrum)
            if (!analyser || !dataArray) {
                console.warn('Analyser or dataArray not initialized');
                return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            
            // Clear with white background
            visualizerCtx.fillStyle = '#fff';
            visualizerCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            
            // ZOOM IN: Only show first 60% of spectrum (where musical content is)
            const relevantBins = Math.floor(dataArray.length * 0.6);
            
            // Draw frequency spectrum as line graph
            visualizerCtx.lineWidth = 2;
            visualizerCtx.strokeStyle = '#000'; // Black line
            visualizerCtx.lineCap = 'round';
            visualizerCtx.lineJoin = 'round';
            visualizerCtx.beginPath();
            
            const sliceWidth = visualizerCanvas.width / relevantBins;
            let x = 0;
            
            // AMPLIFICATION: Multiply by 1.5x for more dramatic visual movement
            const amplification = 1.5;
            
            for (let i = 0; i < relevantBins; i++) {
                let v = dataArray[i] / 255.0;
                v = Math.min(1, v * amplification); // Amplify but clamp to 1.0
                const y = visualizerCanvas.height - (v * visualizerCanvas.height);
                
                if (i === 0) {
                    visualizerCtx.moveTo(x, y);
                } else {
                    visualizerCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            visualizerCtx.stroke();
        }

        // Audio playback with looping
        async function playDataSonification() {
            if (!parsedData) return;
            
            // Handle stop (button acts as toggle)
            if (isPlaying) {
                stopPlayback();
                return;
            }
            
            // Start playback
            isPlaying = true;
            isPaused = false;
            previousDelayTime = null; // Reset for fresh start
            document.getElementById('playIcon').textContent = '‚èπ';
            document.getElementById('playText').textContent = 'Stop';
            visualizerCanvas.classList.add('active');
            
            if (!audioContext) {
                initEffects();
                setupVisualizer();
            } else {
                // Reconnect visualizer if canvas was resized
                if (visualizerCanvas.width !== visualizerCanvas.offsetWidth) {
                    visualizerCanvas.width = visualizerCanvas.offsetWidth;
                    visualizerCanvas.height = 60;
                    console.log('Canvas resized to:', visualizerCanvas.width, 'x', visualizerCanvas.height);
                }
            }
            
            drawVisualizer();
            
            // Reset debug flags for new playback
            window._loggedItemStructure = false;
            window._loggedMissingPaths = {};
            window._loggedMissingElements = {};
            
            const dataArray = Array.isArray(parsedData) ? parsedData : [parsedData];
            
            console.log('=== Playback Starting ===');
            console.log('Data array length:', dataArray.length);
            console.log('First item in data array:', dataArray[0]);
            
            // Calculate data ranges for all mapped parameters ONCE
            const dataRanges = {};
            Object.entries(mappings).forEach(([param, mapping]) => {
                if (mapping && mapping.path) {
                    const values = dataArray.map(item => getValueByPath(item, mapping.path))
                        .filter(v => v !== undefined && !isNaN(parseFloat(v)))
                        .map(v => parseFloat(v));
                    
                    if (values.length > 0) {
                        dataRanges[param] = {
                            min: Math.min(...values),
                            max: Math.max(...values)
                        };
                    }
                }
            });
            
            console.log('Data ranges:', dataRanges);
            
            // Log active mappings
            console.log('=== Active Mappings ===');
            Object.keys(mappings).forEach(param => {
                if (mappings[param].path) {
                    console.log(`‚úì ${param}: ${mappings[param].path} [${mappings[param].min} to ${mappings[param].max}] (${mappings[param].curve})`);
                }
            });
            console.log('======================');
            
            // Loop continuously
            while (isPlaying) {
                for (let i = 0; i < dataArray.length && isPlaying; i++) {
                    // Wait if paused
                    while (isPaused && isPlaying) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    if (!isPlaying) break;
                    
                    const item = dataArray[i];
                    
                    // Helper to calculate mapped parameter value with curve scaling
                    const getParamValue = (paramName) => {
                        const mapping = mappings[paramName];
                        if (!mapping) return null;
                        
                        if (mapping.path && dataRanges[paramName]) {
                            const rawValue = parseFloat(getValueByPath(item, mapping.path));
                            if (isNaN(rawValue)) return mapping.fixed;
                            
                            // Scale from actual data range to audio parameter range
                            const dataMin = dataRanges[paramName].min;
                            const dataMax = dataRanges[paramName].max;
                            
                            if (dataMax === dataMin) return mapping.min;
                            
                            let normalized = (rawValue - dataMin) / (dataMax - dataMin);
                            normalized = Math.max(0, Math.min(1, normalized));
                            
                            // Apply curve transformation
                            let curved = normalized;
                            switch (mapping.curve) {
                                case 'exponential':
                                    curved = Math.pow(normalized, 2);
                                    break;
                                case 'cubic':
                                    curved = Math.pow(normalized, 3);
                                    break;
                                case 'logarithmic':
                                    curved = normalized > 0 ? Math.log(1 + normalized * 9) / Math.log(10) : 0;
                                    break;
                                case 'inverse':
                                    curved = 1 - normalized;
                                    break;
                                case 'linear':
                                default:
                                    curved = normalized;
                                    break;
                            }
                            
                            // Apply to audio range
                            return mapping.min + (curved * (mapping.max - mapping.min));
                        }
                        return mapping.fixed;
                    };
                    
                    // Calculate all audio parameters (mode-specific)
                    const audioParams = {};
                    
                    if (samplerMode) {
                        // Sampler mode: pitch (playback rate) and sampleOffset
                        audioParams.pitch = getParamValue('pitch');
                        audioParams.sampleOffset = getParamValue('sampleOffset');
                    } else {
                        // Synthesizer mode: frequency
                        const frequency = getParamValue('frequency') || 440;
                        audioParams.frequency = frequency;
                    }
                    
                    // Common parameters for both modes
                    audioParams.duration = getParamValue('duration');
                    audioParams.noteSpacing = getParamValue('noteSpacing');
                    audioParams.pan = getParamValue('pan');
                    audioParams.filterFreq = getParamValue('filterFreq');
                    audioParams.filterQ = getParamValue('filterQ');
                    audioParams.delayTime = getParamValue('delayTime');
                    audioParams.delayFeedback = getParamValue('delayFeedback');
                    audioParams.delayMix = getParamValue('delayMix');
                    audioParams.reverbDecay = getParamValue('reverbDecay');
                    audioParams.reverbMix = getParamValue('reverbMix');
                    audioParams.attack = getParamValue('attack');
                    audioParams.release = getParamValue('release');
                    
                    // Update node visualization
                    updateNodeValues(item, audioParams);
                    
                    // Get all audio parameters (use defaults if not mapped)
                    const volume = parseFloat(document.getElementById('masterVolume')?.value || 0.2);
                    const duration = audioParams.duration || 200;
                    const pan = audioParams.pan || 0;
                    const filterFreq = audioParams.filterFreq || 2000;
                    const filterQ = audioParams.filterQ || 1;
                    const attack = audioParams.attack || 10;
                    const release = audioParams.release || 100;
                    
                    // Update delay parameters globally with analog-style pitch shifting
                    let delayTime = audioParams.delayTime || 200;
                    const delayFeedback = audioParams.delayFeedback !== null && audioParams.delayFeedback !== undefined ? audioParams.delayFeedback : 0.3;
                    const delayMix = audioParams.delayMix !== null && audioParams.delayMix !== undefined ? audioParams.delayMix : 0.3;
                    
                    // Add subtle random variation to delay time for organic pitch-shifting layers (¬±15%)
                    const delayTimeVariation = 0.85 + (Math.random() * 0.3); // 0.85 to 1.15 multiplier
                    delayTime = delayTime * delayTimeVariation;
                    
                    if (delayNode && delayFeedbackGain && delayWetGain && delayDryGain) {
                        const now = audioContext.currentTime;
                        const newDelayTimeSeconds = Math.max(0.001, Math.min(2, delayTime / 1000));
                        
                        // Analog delay pitch shifting: when delay time changes, ramp smoothly (creates pitch bend)
                        if (previousDelayTime !== null && Math.abs(newDelayTimeSeconds - previousDelayTime) > 0.005) {
                            // Fast ramp creates pitch shifting effect (like tape speed change)
                            const rampTime = 0.05; // 50ms ramp creates audible pitch shift
                            try {
                                delayNode.delayTime.cancelScheduledValues(now);
                                delayNode.delayTime.setValueAtTime(previousDelayTime, now);
                                delayNode.delayTime.linearRampToValueAtTime(newDelayTimeSeconds, now + rampTime);
                                
                                // Log first analog shift for debugging
                                if (i === 0) {
                                    console.log(`üéõÔ∏è Analog delay shift: ${(previousDelayTime * 1000).toFixed(0)}ms ‚Üí ${delayTime.toFixed(0)}ms (pitch bend)`);
                                }
                            } catch (e) {
                                console.warn('Delay ramp error:', e);
                                delayNode.delayTime.setValueAtTime(newDelayTimeSeconds, now);
                            }
                        } else {
                            delayNode.delayTime.setValueAtTime(newDelayTimeSeconds, now);
                        }
                        previousDelayTime = newDelayTimeSeconds;
                        
                        // Update feedback and mix globally
                        const safeFeedback = Math.max(0, Math.min(0.9, delayFeedback));
                        const safeMix = Math.max(0, Math.min(1, delayMix));
                        
                        delayFeedbackGain.gain.setValueAtTime(safeFeedback, now);
                        delayWetGain.gain.setValueAtTime(safeMix, now);
                        delayDryGain.gain.setValueAtTime(1 - safeMix, now);
                    }
                    
                    // Update reverb parameters (set defaults if not mapped)
                    const reverbDecay = audioParams.reverbDecay || 2;
                    const reverbMix = audioParams.reverbMix !== null && audioParams.reverbMix !== undefined ? audioParams.reverbMix : 0.3;
                    
                    if (reverbNode && reverbWetGain && reverbDryGain) {
                        // Update reverb buffer if decay changed significantly
                        if (!reverbNode.buffer || Math.abs(reverbNode.buffer.duration - reverbDecay) > 0.5) {
                            reverbNode.buffer = createReverbImpulse(reverbDecay, reverbDecay);
                        }
                        
                        const safeReverbMix = Math.max(0, Math.min(1, reverbMix));
                        reverbWetGain.gain.value = safeReverbMix;
                        reverbDryGain.gain.value = 1 - safeReverbMix;
                    }
                    
                    // Log periodically to show values are changing
                    if (i % 5 === 0) {
                        const loggedParams = {
                            item: i + 1,
                            duration: duration.toFixed(0) + 'ms',
                            pan: pan.toFixed(2),
                            filterFreq: filterFreq.toFixed(0) + 'Hz',
                            delayTime: delayTime.toFixed(0) + 'ms'
                        };
                        
                        // Mode-specific parameters
                        if (samplerMode) {
                            const pitch = audioParams.pitch || 1;
                            const offset = audioParams.sampleOffset || 0;
                            loggedParams.pitch = pitch.toFixed(2) + 'x';
                            loggedParams.sampleOffset = (offset * 100).toFixed(0) + '%';
                            
                            // Show raw data values for mapped params
                            if (mappings.pitch?.path) {
                                loggedParams.pitchRaw = getValueByPath(item, mappings.pitch.path);
                            }
                            if (mappings.sampleOffset?.path) {
                                loggedParams.offsetRaw = getValueByPath(item, mappings.sampleOffset.path);
                            }
                        } else {
                            const frequency = audioParams.frequency || 440;
                            loggedParams.frequency = frequency.toFixed(1) + 'Hz';
                            
                            // Show raw data values for mapped params
                            if (mappings.frequency?.path) {
                                loggedParams.freqRaw = getValueByPath(item, mappings.frequency.path);
                            }
                        }
                        
                        if (mappings.filterFreq?.path) {
                            loggedParams.filterRaw = getValueByPath(item, mappings.filterFreq.path);
                        }
                        
                        console.log('üéµ Note ' + (i + 1), loggedParams);
                    }
                    
                    // Play tone with full effects chain
                    const filter = audioContext.createBiquadFilter();
                    const panner = audioContext.createStereoPanner();
                    const envelope = audioContext.createGain();
                    
                    let source; // Will be either oscillator or buffer source
                    
                    if (samplerMode && sampleBuffer) {
                        // SAMPLER MODE: Create buffer source from loaded sample
                        source = audioContext.createBufferSource();
                        source.buffer = sampleBuffer;
                        
                        // Get pitch (playback rate) parameter
                        const pitchRate = audioParams.pitch !== null && audioParams.pitch !== undefined ? audioParams.pitch : 1;
                        
                        // Apply master pitch transpose on top of data-driven rate
                        const pitchTranspose = parseFloat(document.getElementById('pitchControl')?.value || 0);
                        const transposeSemitones = Math.pow(2, pitchTranspose / 12);
                        source.playbackRate.value = pitchRate * transposeSemitones;
                        
                        // Get sample offset parameter (0-1, normalized position in sample)
                        const sampleOffsetNorm = audioParams.sampleOffset !== null && audioParams.sampleOffset !== undefined ? audioParams.sampleOffset : 0;
                        const sampleOffsetSeconds = sampleOffsetNorm * sampleBuffer.duration;
                        
                        // Crop duration: how long to play from offset point (in seconds)
                        const cropDurationSeconds = duration / 1000;
                        
                        // Store for starting/stopping later
                        source._offsetSeconds = sampleOffsetSeconds;
                        source._cropDuration = cropDurationSeconds;
                        
                        // Log first note for debugging
                        if (i === 0) {
                            console.log(`üéµ Sampler: rate=${source.playbackRate.value.toFixed(2)}, offset=${sampleOffsetSeconds.toFixed(2)}s (${(sampleOffsetNorm*100).toFixed(0)}%), crop=${cropDurationSeconds.toFixed(2)}s`);
                        }
                        
                    } else {
                        // SYNTHESIZER MODE: Create oscillator
                        const frequency = audioParams.frequency || 440;
                        
                        // Apply master pitch transpose
                        const pitchTranspose = parseFloat(document.getElementById('pitchControl')?.value || 0);
                        let transposedFrequency = frequency * Math.pow(2, pitchTranspose / 12);
                        
                        // Apply pitch quantization if enabled
                        if (document.getElementById('pitchQuantization')?.checked) {
                            transposedFrequency = quantizePitch(transposedFrequency);
                        }
                        
                        // Get selected waveform type
                        const waveformType = document.querySelector('input[name="waveform"]:checked')?.value || 'sine';
                        
                        // Create oscillator (could be standard oscillator, noise buffer, or FM synth)
                        source = createCustomOscillator(audioContext, transposedFrequency, waveformType, duration);
                    }
                    
                    // Configure filter
                    filter.type = document.querySelector('input[name="filterType"]:checked')?.value || 'lowpass';
                    filter.frequency.value = filterFreq;
                    filter.Q.value = filterQ;
                    
                    // Configure panner
                    panner.pan.value = Math.max(-1, Math.min(1, pan));
                    
                    // Configure envelope with anti-click protection
                    const now = audioContext.currentTime;
                    
                    // For samples, ensure minimum attack/release times to prevent clicks
                    const minSmoothTime = samplerMode ? 0.003 : 0; // 3ms minimum for samples
                    const attackTime = Math.max(minSmoothTime, attack / 1000);
                    const releaseTime = Math.max(minSmoothTime, release / 1000);
                    const durationTime = duration / 1000;
                    
                    // Use exponential ramps for smoother, more natural-sounding envelopes
                    envelope.gain.setValueAtTime(0.001, now); // Start near zero (exponential can't start at 0)
                    envelope.gain.exponentialRampToValueAtTime(volume, now + attackTime);
                    envelope.gain.setValueAtTime(volume, now + Math.max(attackTime, durationTime - releaseTime));
                    envelope.gain.exponentialRampToValueAtTime(0.001, now + durationTime);
                    
                    // Handle additive synthesis (create harmonics) - synth mode only
                    if (!samplerMode && source._isAdditive) {
                        // Create harmonic series (1x, 2x, 3x, 4x frequencies with decreasing amplitude)
                        const harmonicGain = audioContext.createGain();
                        harmonicGain.gain.value = 0.6; // Reduce fundamental
                        source.connect(harmonicGain);
                        harmonicGain.connect(filter);
                        
                        // Add 3 harmonics
                        const frequency = audioParams.frequency || 440;
                        const pitchTranspose = parseFloat(document.getElementById('pitchControl')?.value || 0);
                        const transposedFrequency = frequency * Math.pow(2, pitchTranspose / 12);
                        
                        for (let h = 2; h <= 4; h++) {
                            const harmonic = audioContext.createOscillator();
                            const hGain = audioContext.createGain();
                            harmonic.frequency.value = transposedFrequency * h;
                            harmonic.type = 'sine';
                            hGain.gain.value = 0.3 / h; // Decreasing amplitude
                            harmonic.connect(hGain);
                            hGain.connect(filter);
                            harmonic.start(now);
                            harmonic.stop(now + durationTime);
                        }
                    } else {
                        // Standard connection (both sampler and non-additive synth)
                        source.connect(filter);
                    }
                    
                    // Connect rest of chain
                    filter.connect(panner);
                    panner.connect(envelope);
                    envelope.connect(delayNode);
                    envelope.connect(delayDryGain);
                    
                    // Start and stop source
                    if (samplerMode && source._offsetSeconds !== undefined) {
                        // Sampler mode: start at offset, play for crop duration
                        source.start(now, source._offsetSeconds, source._cropDuration);
                    } else {
                        // Synthesizer mode: standard start/stop
                        source.start(now);
                        source.stop(now + durationTime);
                        
                        // Start/stop FM modulator if present
                        if (source._modulator) {
                            source._modulator.start(now);
                            source._modulator.stop(now + durationTime);
                        }
                    }
                    
                    // Calculate note spacing: use mapped value if available, otherwise use speed slider WITH VARIATION
                    let noteSpacing;
                    if (audioParams.noteSpacing !== null && audioParams.noteSpacing !== undefined) {
                        // Mapped to data: use the value directly
                        noteSpacing = audioParams.noteSpacing;
                    } else {
                        // Not mapped: add automatic rhythmic variation for more musical feel
                        const speed = document.getElementById('speedControl')?.value || 1;
                        const baseSpacing = 500 / speed;
                        
                        // Add subtle random variation (¬±20%) to create natural rhythm
                        const variation = 0.2; // 20% variation
                        const randomFactor = 1 + (Math.random() * variation * 2 - variation); // 0.8 to 1.2
                        noteSpacing = baseSpacing * randomFactor;
                        
                        // Alternative: use item index for pattern-based variation
                        // Creates accelerando/ritardando effects instead of random
                        // const phase = (i / dataArray.length) * Math.PI * 2;
                        // noteSpacing = baseSpacing * (1 + Math.sin(phase) * 0.3);
                    }
                    
                    // Apply rhythmic quantization if enabled
                    let actualDelay = noteSpacing;
                    if (document.getElementById('rhythmicQuantization')?.checked) {
                        actualDelay = quantizeRhythm(noteSpacing);
                    }
                    
                    // Update labeled displays
                    document.getElementById('itemValue').textContent = `${i + 1} / ${dataArray.length}`;
                    
                    await new Promise(resolve => {
                        currentTimeout = setTimeout(resolve, actualDelay);
                    });
                }
            }
            
            isPlaying = false;
            isPaused = false;
            document.getElementById('playIcon').textContent = '‚ñ∂';
            document.getElementById('playText').textContent = 'Play Data';
            visualizerCanvas.classList.remove('active');
            cancelAnimationFrame(animationId);
            clearNodeValues();
        }

        function stopPlayback() {
            isPlaying = false;
            isPaused = false;
            previousDelayTime = null; // Reset for next playback
            if (currentTimeout) clearTimeout(currentTimeout);
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('playDataBtn').disabled = false;
            document.getElementById('playIcon').textContent = '‚ñ∂';
            document.getElementById('playText').textContent = 'Play Data';
            visualizerCanvas.classList.remove('active');
            document.getElementById('itemValue').textContent = '--';
            clearNodeValues();
        }

        document.getElementById('playDataBtn').addEventListener('click', playDataSonification);
        
        // Redraw patch visualization on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log('Window resized, redrawing patch...');
                updatePatchVisualization();
            }, 250); // Debounce resize events
        });

        console.log('üéµ data 2 sound loaded and ready');
    </script>
</body>
</html>

