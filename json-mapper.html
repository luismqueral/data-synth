<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>JSON to Sound Mapper</title>
    <link rel="stylesheet" href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        * {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        #mappingControls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px 30px;
            max-width: 1200px;
        }
        
        #patchViz {
            border: 1px solid #000;
            background: white;
        }
        
        .node-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            fill: #000;
        }
        
        .connection-line {
            stroke: #000;
            stroke-width: 1;
            fill: none;
        }
        
        .connection-line.active {
            stroke-width: 2;
        }
        
        .node-dot {
            fill: #000;
        }
        
        #pathsTable {
            border-collapse: collapse;
            font-size: 11px;
        }
        
        #pathsTable th {
            text-align: left;
            border-bottom: 2px solid #000;
            padding: 4px 8px;
            font-weight: 600;
        }
        
        #pathsTable td {
            padding: 3px 8px;
            border-bottom: 1px solid #ccc;
        }
        
        .success-msg {
            color: #000;
            font-size: 12px;
        }
    </style>
</head>
<body class="pa3 f6">
    <h1 class="f2 mb3">JSON to Sound Mapper</h1>
    
    <h2 class="f3 mb2 mt4">1. Input JSON</h2>
    <textarea id="jsonInput" rows="15" cols="80" class="w-100 pa2 ba b--black-20 f6"></textarea>
    <div class="mt2 mb3">
        <button id="playBtn" disabled class="mr2 pa2 ba b--black bg-black white pointer hover-bg-white hover-black b">Play Sonification</button>
        <button id="parseBtn" class="pa2 ba b--black bg-white pointer hover-bg-black hover-white">Parse JSON</button>
        <span id="parseStatus" class="ml3 success-msg"></span>
    </div>
    
    <div id="pathsTableContainer" class="mb3" style="display: none;">
        <div class="b mb2 f6">Detected Paths:</div>
        <table id="pathsTable" class="w-100">
            <thead>
                <tr>
                    <th>Path</th>
                    <th>Type</th>
                    <th>Sample Value</th>
                </tr>
            </thead>
            <tbody id="pathsTableBody"></tbody>
        </table>
    </div>
    
    <h3 class="f4 mb2 mt3">Patch Visualization</h3>
    <svg id="patchViz" width="800" height="300" class="mb3"></svg>
    
    <h2 class="f3 mb2 mt4">2. Map to Audio Parameters</h2>
    <div class="mb3">
        <button id="randomizeMappingsBtn" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize Mappings</button>
        <button id="randomizeRangesBtn" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize Ranges</button>
        <button id="randomizeAllBtn" disabled class="pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize All</button>
    </div>
    <div id="mappingControls" class="mb3"></div>
    
    <h3 class="f4 mb2 mt4">Waveform Type</h3>
    <div class="mb3">
        <label class="mr3">
            <input type="radio" name="waveform" value="sine" checked class="mr1"> Sine
        </label>
        <label class="mr3">
            <input type="radio" name="waveform" value="square" class="mr1"> Square
        </label>
        <label class="mr3">
            <input type="radio" name="waveform" value="sawtooth" class="mr1"> Sawtooth
        </label>
        <label class="mr3">
            <input type="radio" name="waveform" value="triangle" class="mr1"> Triangle
        </label>
    </div>
    
    <h3 class="f4 mb2 mt3">Filter Type</h3>
    <div class="mb3">
        <label class="mr3">
            <input type="radio" name="filterType" value="lowpass" checked class="mr1"> Lowpass
        </label>
        <label class="mr3">
            <input type="radio" name="filterType" value="highpass" class="mr1"> Highpass
        </label>
        <label class="mr3">
            <input type="radio" name="filterType" value="bandpass" class="mr1"> Bandpass
        </label>
        <label class="mr3">
            <input type="radio" name="filterType" value="notch" class="mr1"> Notch
        </label>
    </div>
    
    <h2 class="f3 mb2 mt4">3. Playback Controls</h2>
    <div class="mb3">
        <button id="stopBtn" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Stop</button>
        <label class="mr2">Speed: <input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1" class="ml2"></label>
        <span id="speedValue">1x</span>
    </div>
    
    <h3 class="f4 mb2">Playback Info</h3>
    <pre id="infoOutput" class="f6 pa2 bg-near-white"></pre>

    <script>
        // Audio Context
        let audioContext;
        let isPlaying = false;
        let currentTimeout;
        
        // Data
        let parsedData = null;
        let detectedPaths = [];
        let numericPaths = [];
        let mappings = {};
        
        // Elements
        const jsonInput = document.getElementById('jsonInput');
        const parseBtn = document.getElementById('parseBtn');
        const parseStatus = document.getElementById('parseStatus');
        const pathsTableContainer = document.getElementById('pathsTableContainer');
        const pathsTableBody = document.getElementById('pathsTableBody');
        const mappingControls = document.getElementById('mappingControls');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const infoOutput = document.getElementById('infoOutput');
        const randomizeMappingsBtn = document.getElementById('randomizeMappingsBtn');
        const randomizeRangesBtn = document.getElementById('randomizeRangesBtn');
        const randomizeAllBtn = document.getElementById('randomizeAllBtn');
        
        // Sample JSON
        jsonInput.value = `[
  {
    "name": "Alice",
    "age": 30,
    "score": 85,
    "category": "A"
  },
  {
    "name": "Bob",
    "age": 25,
    "score": 92,
    "category": "B"
  },
  {
    "name": "Charlie",
    "age": 35,
    "score": 78,
    "category": "A"
  },
  {
    "name": "Diana",
    "age": 28,
    "score": 95,
    "category": "C"
  }
]`;
        
        speedControl.addEventListener('input', (e) => {
            speedValue.textContent = `${e.target.value}x`;
        });
        
        // Extract all paths from JSON
        function extractPaths(obj, prefix = '') {
            const paths = [];
            
            if (Array.isArray(obj)) {
                if (obj.length > 0) {
                    // Analyze first item to understand structure
                    const sample = obj[0];
                    if (typeof sample === 'object' && sample !== null) {
                        const subPaths = extractPaths(sample, prefix);
                        paths.push(...subPaths);
                    } else {
                        paths.push({
                            path: prefix || 'root',
                            type: typeof sample,
                            isArray: true,
                            sample: obj.slice(0, 3)
                        });
                    }
                }
            } else if (typeof obj === 'object' && obj !== null) {
                for (const key in obj) {
                    const fullPath = prefix ? `${prefix}.${key}` : key;
                    const value = obj[key];
                    
                    if (Array.isArray(value)) {
                        paths.push(...extractPaths(value, fullPath));
                    } else if (typeof value === 'object' && value !== null) {
                        paths.push(...extractPaths(value, fullPath));
                    } else {
                        paths.push({
                            path: fullPath,
                            type: typeof value,
                            isArray: false,
                            sample: value
                        });
                    }
                }
            }
            
            return paths;
        }
        
        // Get value from object using path
        function getValueByPath(obj, path) {
            return path.split('.').reduce((curr, key) => curr?.[key], obj);
        }
        
        // Extract values from array data
        function extractValues(data, path) {
            if (Array.isArray(data)) {
                return data.map(item => getValueByPath(item, path)).filter(v => v !== undefined);
            }
            return [getValueByPath(data, path)].filter(v => v !== undefined);
        }
        
        // Parse JSON
        parseBtn.addEventListener('click', () => {
            try {
                parsedData = JSON.parse(jsonInput.value);
                detectedPaths = extractPaths(parsedData);
                
                // Filter to numeric paths (for audio mapping)
                numericPaths = detectedPaths.filter(p => p.type === 'number');
                
                // Display paths in table
                pathsTableBody.innerHTML = '';
                detectedPaths.forEach(path => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${path.path}</td>
                        <td>${path.type}</td>
                        <td>${path.sample}</td>
                    `;
                    pathsTableBody.appendChild(row);
                });
                
                pathsTableContainer.style.display = 'block';
                
                // Create mapping controls
                createMappingControls(numericPaths);
                
                playBtn.disabled = false;
                randomizeMappingsBtn.disabled = false;
                randomizeRangesBtn.disabled = false;
                randomizeAllBtn.disabled = false;
                
                // Auto-randomize mappings on parse
                randomizeMappings();
                
                // Show success message
                parseStatus.textContent = `✓ Parsed ${detectedPaths.length} paths (${numericPaths.length} numeric). Mappings randomized.`;
                
            } catch (e) {
                parseStatus.textContent = `✗ Error: ${e.message}`;
                pathsTableContainer.style.display = 'none';
            }
        });
        
        // Create mapping UI
        function createMappingControls(numericPaths) {
            mappingControls.innerHTML = '';
            
            const audioParams = [
                { id: 'frequency', label: 'Frequency (Hz)', min: 200, max: 2000, default: 440 },
                { id: 'duration', label: 'Duration (ms)', min: 50, max: 2000, default: 200 },
                { id: 'volume', label: 'Volume', min: 0, max: 1, default: 0.3 },
                { id: 'noteSpacing', label: 'Note Spacing (ms)', min: 50, max: 2000, default: 500 },
                { id: 'pan', label: 'Pan (-1=Left, 1=Right)', min: -1, max: 1, default: 0 },
                { id: 'filterFreq', label: 'Filter Frequency (Hz)', min: 200, max: 8000, default: 2000 },
                { id: 'filterQ', label: 'Filter Resonance (Q)', min: 0.1, max: 20, default: 1 },
                { id: 'delayTime', label: 'Delay Time (ms)', min: 0, max: 1000, default: 200 },
                { id: 'delayFeedback', label: 'Delay Feedback', min: 0, max: 0.9, default: 0.3 },
                { id: 'delayMix', label: 'Delay Mix', min: 0, max: 1, default: 0.3 },
                { id: 'reverbDecay', label: 'Reverb Decay (s)', min: 0.1, max: 10, default: 2 },
                { id: 'reverbMix', label: 'Reverb Mix', min: 0, max: 1, default: 0.3 },
                { id: 'attack', label: 'Attack (ms)', min: 1, max: 1000, default: 10 },
                { id: 'release', label: 'Release (ms)', min: 1, max: 2000, default: 100 }
            ];
            
            audioParams.forEach(param => {
                const div = document.createElement('div');
                div.className = 'bg-black-05 pa2';
                div.innerHTML = `
                    <div class="b mb2 f6">${param.label}</div>
                    <label class="db mb2">
                        <span class="db mb1">Path:</span>
                        <select id="map_${param.id}" class="w-100 pa1 ba b--black-20 f6">
                            <option value="">-- Fixed --</option>
                            ${numericPaths.map(p => `<option value="${p.path}">${p.path}</option>`).join('')}
                        </select>
                    </label>
                    <div class="flex items-center mb2">
                        <label class="mr2 flex-auto">
                            <span class="db mb1">Fixed:</span>
                            <input type="number" id="fixed_${param.id}" value="${param.default}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                        <label class="mr2 flex-auto">
                            <span class="db mb1">Min:</span>
                            <input type="number" id="min_${param.id}" value="${param.min}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                        <label class="flex-auto">
                            <span class="db mb1">Max:</span>
                            <input type="number" id="max_${param.id}" value="${param.max}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                    </div>
                    <label class="db">
                        <span class="db mb1">Curve:</span>
                        <select id="curve_${param.id}" class="w-100 pa1 ba b--black-20 f6">
                            <option value="linear">Linear (normal)</option>
                            <option value="exponential">Exponential (amplify high)</option>
                            <option value="cubic">Cubic (dramatic)</option>
                            <option value="logarithmic">Logarithmic (amplify low)</option>
                            <option value="inverse">Inverse (flip)</option>
                        </select>
                    </label>
                `;
                mappingControls.appendChild(div);
                
                // Initialize mapping
                mappings[param.id] = {
                    path: '',
                    fixed: param.default,
                    min: param.min,
                    max: param.max,
                    curve: 'linear'
                };
                
                // Add event listeners
                document.getElementById(`map_${param.id}`).addEventListener('change', (e) => {
                    mappings[param.id].path = e.target.value;
                    updatePatchVisualization();
                });
                
                document.getElementById(`fixed_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].fixed = parseFloat(e.target.value);
                });
                
                document.getElementById(`min_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].min = parseFloat(e.target.value);
                });
                
                document.getElementById(`max_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].max = parseFloat(e.target.value);
                });
                
                document.getElementById(`curve_${param.id}`).addEventListener('change', (e) => {
                    mappings[param.id].curve = e.target.value;
                });
            });
            
            // Initial patch visualization
            updatePatchVisualization();
        }
        
        // Update patch visualization
        function updatePatchVisualization() {
            const svg = d3.select('#patchViz');
            svg.selectAll('*').remove();
            
            const width = 800;
            const height = 300;
            const margin = { left: 10, right: 10, top: 20, bottom: 20 };
            
            // Get active mappings
            const activeMappings = Object.entries(mappings)
                .filter(([_, mapping]) => mapping && mapping.path)
                .map(([paramId, mapping]) => ({
                    source: mapping.path,
                    target: paramId,
                    curve: mapping.curve || 'linear'
                }));
            
            // Get unique sources (data paths) and targets (audio params)
            const sources = [...new Set(activeMappings.map(m => m.source))];
            const targets = [...new Set(activeMappings.map(m => m.target))];
            
            if (sources.length === 0 || targets.length === 0) {
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .attr('class', 'node-label')
                    .text('Map parameters to see connections');
                return;
            }
            
            // Calculate positions
            const sourceX = margin.left + 100;
            const targetX = width - margin.right - 100;
            const sourceSpacing = (height - margin.top - margin.bottom) / (sources.length + 1);
            const targetSpacing = (height - margin.top - margin.bottom) / (targets.length + 1);
            
            // Position data
            const sourcePositions = {};
            sources.forEach((source, i) => {
                sourcePositions[source] = {
                    x: sourceX,
                    y: margin.top + (i + 1) * sourceSpacing
                };
            });
            
            const targetPositions = {};
            targets.forEach((target, i) => {
                targetPositions[target] = {
                    x: targetX,
                    y: margin.top + (i + 1) * targetSpacing
                };
            });
            
            // Draw connections
            const g = svg.append('g');
            
            activeMappings.forEach(mapping => {
                const sourcePos = sourcePositions[mapping.source];
                const targetPos = targetPositions[mapping.target];
                
                if (sourcePos && targetPos) {
                    // Draw curved line
                    const midX = (sourcePos.x + targetPos.x) / 2;
                    
                    g.append('path')
                        .attr('class', 'connection-line active')
                        .attr('d', `M ${sourcePos.x},${sourcePos.y} C ${midX},${sourcePos.y} ${midX},${targetPos.y} ${targetPos.x},${targetPos.y}`)
                        .attr('opacity', 0.6);
                }
            });
            
            // Draw source nodes (left side - data paths)
            sources.forEach(source => {
                const pos = sourcePositions[source];
                
                g.append('circle')
                    .attr('class', 'node-dot')
                    .attr('cx', pos.x)
                    .attr('cy', pos.y)
                    .attr('r', 3);
                
                g.append('text')
                    .attr('class', 'node-label')
                    .attr('x', pos.x - 5)
                    .attr('y', pos.y + 3)
                    .attr('text-anchor', 'end')
                    .text(source);
            });
            
            // Draw target nodes (right side - audio params)
            targets.forEach(target => {
                const pos = targetPositions[target];
                
                g.append('circle')
                    .attr('class', 'node-dot')
                    .attr('cx', pos.x)
                    .attr('cy', pos.y)
                    .attr('r', 3);
                
                g.append('text')
                    .attr('class', 'node-label')
                    .attr('x', pos.x + 5)
                    .attr('y', pos.y + 3)
                    .attr('text-anchor', 'start')
                    .text(target);
            });
            
            // Add labels
            g.append('text')
                .attr('x', sourceX)
                .attr('y', margin.top - 5)
                .attr('text-anchor', 'middle')
                .attr('class', 'node-label')
                .style('font-weight', 'bold')
                .text('DATA');
            
            g.append('text')
                .attr('x', targetX)
                .attr('y', margin.top - 5)
                .attr('text-anchor', 'middle')
                .attr('class', 'node-label')
                .style('font-weight', 'bold')
                .text('AUDIO');
        }
        
        // Randomization functions
        function randomElement(array) {
            return array[Math.floor(Math.random() * array.length)];
        }
        
        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        function randomizeMappings() {
            const paramIds = Object.keys(mappings);
            const curves = ['linear', 'exponential', 'cubic', 'logarithmic', 'inverse'];
            
            paramIds.forEach(paramId => {
                // Randomly decide to map or not (70% chance to map)
                if (Math.random() > 0.3 && numericPaths.length > 0) {
                    const randomPath = randomElement(numericPaths).path;
                    document.getElementById(`map_${paramId}`).value = randomPath;
                    mappings[paramId].path = randomPath;
                    
                    // Randomize curve (favor linear and exponential)
                    const randomCurve = Math.random() < 0.5 ? 'linear' : randomElement(curves);
                    document.getElementById(`curve_${paramId}`).value = randomCurve;
                    mappings[paramId].curve = randomCurve;
                } else {
                    document.getElementById(`map_${paramId}`).value = '';
                    mappings[paramId].path = '';
                }
            });
            
            // Randomize waveform
            const waveforms = ['sine', 'square', 'sawtooth', 'triangle'];
            const randomWaveform = randomElement(waveforms);
            document.querySelector(`input[name="waveform"][value="${randomWaveform}"]`).checked = true;
            
            // Randomize filter type
            const filterTypes = ['lowpass', 'highpass', 'bandpass', 'notch'];
            const randomFilterType = randomElement(filterTypes);
            document.querySelector(`input[name="filterType"][value="${randomFilterType}"]`).checked = true;
            
            updatePatchVisualization();
            infoOutput.textContent = 'Mappings randomized!';
        }
        
        function randomizeRanges() {
            const paramIds = Object.keys(mappings);
            
            paramIds.forEach(paramId => {
                const mapping = mappings[paramId];
                const baseMin = mapping.min;
                const baseMax = mapping.max;
                const range = baseMax - baseMin;
                
                // Generate random min/max within reasonable bounds
                const newMin = baseMin + randomRange(-range * 0.2, range * 0.3);
                const newMax = baseMax + randomRange(-range * 0.3, range * 0.5);
                
                // Ensure min < max
                const actualMin = Math.min(newMin, newMax);
                const actualMax = Math.max(newMin, newMax);
                
                document.getElementById(`min_${paramId}`).value = actualMin.toFixed(2);
                document.getElementById(`max_${paramId}`).value = actualMax.toFixed(2);
                mappings[paramId].min = actualMin;
                mappings[paramId].max = actualMax;
            });
            
            infoOutput.textContent = 'Ranges randomized!';
        }
        
        function randomizeAll() {
            randomizeMappings();
            randomizeRanges();
            infoOutput.textContent = 'All parameters randomized!';
        }
        
        // Add event listeners for randomization
        randomizeMappingsBtn.addEventListener('click', randomizeMappings);
        randomizeRangesBtn.addEventListener('click', randomizeRanges);
        randomizeAllBtn.addEventListener('click', randomizeAll);
        
        // Scale value from data range to audio range with curve options
        function scaleValue(value, dataMin, dataMax, audioMin, audioMax, curve = 'linear') {
            // Safety checks
            if (!isFinite(value)) return audioMin;
            if (!isFinite(dataMin) || !isFinite(dataMax)) return audioMin;
            if (!isFinite(audioMin) || !isFinite(audioMax)) return audioMin;
            if (dataMax === dataMin) return audioMin;
            
            // Normalize to 0-1
            let normalized = (value - dataMin) / (dataMax - dataMin);
            
            // Clamp to 0-1 range to prevent issues
            normalized = Math.max(0, Math.min(1, normalized));
            
            // Apply curve transformation
            switch(curve) {
                case 'exponential':
                    // Exponential: amplifies differences, especially at high end
                    normalized = normalized * normalized;
                    break;
                case 'logarithmic':
                    // Logarithmic: compresses high values, expands low values
                    normalized = Math.sqrt(normalized);
                    break;
                case 'cubic':
                    // Cubic: even more dramatic than exponential
                    normalized = normalized * normalized * normalized;
                    break;
                case 'inverse':
                    // Inverse: flips the range
                    normalized = 1 - normalized;
                    break;
                case 'linear':
                default:
                    // Keep as-is
                    break;
            }
            
            const result = audioMin + (normalized * (audioMax - audioMin));
            
            // Final safety check
            return isFinite(result) ? result : audioMin;
        }
        
        // Global audio nodes for effects
        let delayNode, delayFeedbackGain, delayWetGain, delayDryGain;
        let reverbNode, reverbWetGain, reverbDryGain;
        
        // Create impulse response for reverb
        function createReverbImpulse(duration, decay) {
            if (!audioContext) return null;
            
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                }
            }
            return impulse;
        }
        
        // Initialize global effects
        function initEffects() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Delay setup
            delayNode = audioContext.createDelay(2.0);
            delayFeedbackGain = audioContext.createGain();
            delayWetGain = audioContext.createGain();
            delayDryGain = audioContext.createGain();
            
            delayNode.connect(delayFeedbackGain);
            delayFeedbackGain.connect(delayNode);
            delayNode.connect(delayWetGain);
            
            // Reverb setup
            reverbNode = audioContext.createConvolver();
            reverbNode.buffer = createReverbImpulse(2, 2);
            reverbWetGain = audioContext.createGain();
            reverbDryGain = audioContext.createGain();
            
            reverbNode.connect(reverbWetGain);
            
            // Connect effects to destination
            delayWetGain.connect(reverbNode);
            delayWetGain.connect(reverbDryGain);
            delayDryGain.connect(reverbNode);
            delayDryGain.connect(audioContext.destination);
            reverbWetGain.connect(audioContext.destination);
        }
        
        // Ensure value is a finite number
        function ensureFinite(value, defaultValue) {
            return (typeof value === 'number' && isFinite(value)) ? value : defaultValue;
        }
        
        // Play sound with all parameters
        function playTone(params) {
            if (!audioContext) {
                initEffects();
            }
            
            // Validate and sanitize all parameters
            const frequency = ensureFinite(params.frequency, 440);
            const duration = ensureFinite(params.duration, 200);
            const volume = ensureFinite(params.volume, 0.3);
            const pan = ensureFinite(params.pan, 0);
            const filterFreq = ensureFinite(params.filterFreq, 2000);
            const filterQ = ensureFinite(params.filterQ, 1);
            const delayTime = ensureFinite(params.delayTime, 200);
            const delayFeedback = ensureFinite(params.delayFeedback, 0.3);
            const delayMix = ensureFinite(params.delayMix, 0.3);
            const reverbDecay = ensureFinite(params.reverbDecay, 2);
            const reverbMix = ensureFinite(params.reverbMix, 0.3);
            const attack = ensureFinite(params.attack, 10);
            const release = ensureFinite(params.release, 100);
            const filterType = params.filterType || 'lowpass';
            const waveform = params.waveform || 'sine';
            
            const now = audioContext.currentTime;
            
            // Create oscillator
            const oscillator = audioContext.createOscillator();
            oscillator.frequency.value = frequency;
            oscillator.type = waveform;
            
            // Create filter
            const filter = audioContext.createBiquadFilter();
            filter.type = filterType;
            filter.frequency.value = filterFreq;
            filter.Q.value = filterQ;
            
            // Create panner
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, pan)); // Clamp to -1 to 1
            
            // Create envelope
            const envelope = audioContext.createGain();
            const attackTime = attack / 1000;
            const releaseTime = release / 1000;
            const durationTime = duration / 1000;
            
            envelope.gain.setValueAtTime(0, now);
            envelope.gain.linearRampToValueAtTime(volume, now + attackTime);
            envelope.gain.setValueAtTime(volume, now + Math.max(attackTime, durationTime - releaseTime));
            envelope.gain.linearRampToValueAtTime(0, now + durationTime);
            
            // Connect audio chain
            oscillator.connect(filter);
            filter.connect(panner);
            panner.connect(envelope);
            
            // Connect to delay
            envelope.connect(delayNode);
            envelope.connect(delayDryGain);
            
            // Update delay parameters
            delayNode.delayTime.value = Math.min(2, delayTime / 1000); // Clamp to max 2 seconds
            delayFeedbackGain.gain.value = Math.max(0, Math.min(0.99, delayFeedback)); // Clamp 0-0.99
            delayWetGain.gain.value = Math.max(0, Math.min(1, delayMix)); // Clamp 0-1
            delayDryGain.gain.value = Math.max(0, Math.min(1, 1 - delayMix));
            
            // Update reverb parameters
            if (reverbNode.buffer === null || reverbNode.buffer.duration !== reverbDecay) {
                reverbNode.buffer = createReverbImpulse(reverbDecay, reverbDecay);
            }
            reverbWetGain.gain.value = Math.max(0, Math.min(1, reverbMix)); // Clamp 0-1
            reverbDryGain.gain.value = Math.max(0, Math.min(1, 1 - reverbMix));
            
            // Start and stop
            oscillator.start(now);
            oscillator.stop(now + durationTime);
        }
        
        // Play sonification
        playBtn.addEventListener('click', async () => {
            if (isPlaying) return;
            
            isPlaying = true;
            playBtn.disabled = true;
            stopBtn.disabled = false;
            
            try {
                // Ensure we have array data
                const dataArray = Array.isArray(parsedData) ? parsedData : [parsedData];
                
                // Get all values for each mapped parameter
                const paramData = {};
                for (const [param, mapping] of Object.entries(mappings)) {
                    if (mapping.path) {
                        const values = extractValues(dataArray, mapping.path);
                        const numericValues = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
                        paramData[param] = {
                            values: numericValues,
                            min: Math.min(...numericValues),
                            max: Math.max(...numericValues)
                        };
                    }
                }
                
                // Play each data point
                const speed = parseFloat(speedControl.value);
                const baseDelay = 500 / speed; // ms between notes
                
                for (let i = 0; i < dataArray.length; i++) {
                    if (!isPlaying) break;
                    
                    const item = dataArray[i];
                    
                    // Helper function to get parameter value
                    const getParam = (paramName) => {
                        const mapping = mappings[paramName];
                        if (!mapping) return 0; // Safety check
                        if (mapping.path && paramData[paramName]) {
                            return scaleValue(
                                getValueByPath(item, mapping.path),
                                paramData[paramName].min,
                                paramData[paramName].max,
                                mapping.min,
                                mapping.max,
                                mapping.curve || 'linear'
                            );
                        }
                        return mapping.fixed;
                    };
                    
                    // Calculate all audio parameters
                    const waveformType = document.querySelector('input[name="waveform"]:checked').value;
                    const filterTypeValue = document.querySelector('input[name="filterType"]:checked').value;
                    
                    const audioParams = {
                        frequency: getParam('frequency'),
                        duration: getParam('duration'),
                        volume: getParam('volume'),
                        noteSpacing: getParam('noteSpacing'),
                        pan: getParam('pan'),
                        filterFreq: getParam('filterFreq'),
                        filterQ: getParam('filterQ'),
                        filterType: filterTypeValue,
                        delayTime: getParam('delayTime'),
                        delayFeedback: getParam('delayFeedback'),
                        delayMix: getParam('delayMix'),
                        reverbDecay: getParam('reverbDecay'),
                        reverbMix: getParam('reverbMix'),
                        attack: getParam('attack'),
                        release: getParam('release'),
                        waveform: waveformType
                    };
                    
                    // Use note spacing if mapped, otherwise use baseDelay
                    let actualSpacing = (mappings.noteSpacing && mappings.noteSpacing.path)
                        ? audioParams.noteSpacing / speed 
                        : baseDelay;
                    
                    // Ensure minimum spacing to prevent overwhelming the browser
                    actualSpacing = Math.max(actualSpacing, 10);
                    
                    infoOutput.textContent = `Playing item ${i + 1}/${dataArray.length}\n` +
                        `Freq: ${audioParams.frequency.toFixed(1)} Hz, ` +
                        `Dur: ${audioParams.duration.toFixed(0)} ms, ` +
                        `Vol: ${audioParams.volume.toFixed(2)}\n` +
                        `Spacing: ${actualSpacing.toFixed(0)} ms, ` +
                        `Pan: ${audioParams.pan.toFixed(2)}, ` +
                        `Filter: ${audioParams.filterFreq.toFixed(0)} Hz\n` +
                        `Delay: ${audioParams.delayTime.toFixed(0)} ms, ` +
                        `Reverb: ${audioParams.reverbDecay.toFixed(1)} s`;
                    
                    playTone(audioParams);
                    
                    // Wait before next note
                    await new Promise(resolve => {
                        currentTimeout = setTimeout(resolve, actualSpacing);
                    });
                }
                
                infoOutput.textContent += '\nPlayback complete.';
                
            } catch (e) {
                infoOutput.textContent = `Error during playback: ${e.message}`;
            } finally {
                isPlaying = false;
                playBtn.disabled = false;
                stopBtn.disabled = true;
            }
        });
        
        // Stop playback
        stopBtn.addEventListener('click', () => {
            isPlaying = false;
            if (currentTimeout) {
                clearTimeout(currentTimeout);
            }
            playBtn.disabled = false;
            stopBtn.disabled = true;
            infoOutput.textContent += '\nPlayback stopped.';
        });
        
    </script>
</body>
</html>

