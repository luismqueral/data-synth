<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataSynth</title>
    <link rel="stylesheet" href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        /* Tachyons-style utility: IBM Plex Mono font family */
        .ibm-mono { font-family: 'IBM Plex Mono', monospace; }
        .ibm-mono-i { font-family: 'IBM Plex Mono', monospace; font-style: italic; }
        
        body {
            margin: 0;
            padding: 0;
            background: #fff;
        }
        
        .section {
            margin-bottom: 40px;
            padding-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .section:last-of-type {
            border-bottom: none;
        }
        
        .section-header {
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #000;
        }
        
        .settings-drawer {
            border: 1px solid #e0e0e0;
            background: #f5f5f5;
            margin-bottom: 20px;
        }
        
        .settings-drawer-header {
            padding: 12px 16px;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .settings-drawer-header:hover {
            background: #fafafa;
        }
        
        .settings-drawer-content {
            padding: 20px;
            display: none;
        }
        
        .settings-drawer-content.open {
            display: block;
        }
        
        .drawer-toggle {
            font-size: 14px;
            transition: transform 0.2s;
        }
        
        .drawer-toggle.open {
            transform: rotate(180deg);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .content-wrapper {
                padding: 12px !important;
                max-width: 100% !important;
            }
            
            h1 {
                font-size: 2rem !important;
            }
            
            #playDataBtn {
                min-width: 140px !important;
                padding: 12px 16px !important;
                font-size: 18px !important;
            }
            
            #playDataBtn #playIcon, #playDataBtn #playText {
                font-size: 18px !important;
            }
            
            #templateSelector {
                width: 100% !important;
            }
            
            .settings-drawer-content {
                padding: 12px !important;
            }
            
            #patchViz {
                overflow-x: auto;
            }
        }
        
        @media (min-width: 769px) and (max-width: 1200px) {
            #templateSelector {
                width: 500px !important;
            }
        }
        
        #jsonEditor {
            width: 100%;
            height: 400px;
            padding: 12px;
            border: 1px solid #000;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            background: #fafafa;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 40px;
            text-align: center;
            color: #999;
            margin-bottom: 20px;
            transition: all 0.2s;
        }
        
        .drop-zone.drag-over {
            border-color: #000;
            background: #f5f5f5;
            color: #000;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }
        
        .data-table th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 2px solid #000;
            font-weight: 600;
            background: #f5f5f5;
        }
        
        .data-table td {
            padding: 6px 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .data-table tr:hover {
            background: #fafafa;
        }
        
        .json-syntax {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .json-key { color: #0066cc; }
        .json-string { color: #008800; }
        .json-number { color: #cc0000; }
        .json-boolean { color: #cc0066; }
        .json-null { color: #999; }
        
        .content-wrapper {
            padding-bottom: 20px;
        }
        
        #audioVisualizer {
            background: #eee;
            display: none;
        }
        
        #audioVisualizer.active {
            display: block;
        }
        
        .playback-labels {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 10px;
            color: #666;
            min-width: 80px;
            text-align: center;
        }
        
        .playback-value {
            font-size: 14px;
            color: #000;
            font-weight: 600;
        }
        
        .node-rect {
            fill: #fff;
            stroke: none;
            cursor: default;
        }
        
        .node.unmapped {
            opacity: 0.4;
        }
        
        .node.unmapped rect {
            fill: #f5f5f5;
        }
        
        .node.hover-dimmed {
            opacity: 0.2;
            transition: opacity 0.2s;
        }
        
        .node {
            transition: opacity 0.2s;
        }
        
        .connection-path.hover-dimmed,
        .connection-path-yellow.hover-dimmed {
            opacity: 0.2;
            transition: opacity 0.2s;
        }
        
        .connection-path,
        .connection-path-yellow {
            transition: opacity 0.2s;
        }
        
        .param-bar-fill {
            transition: width 0.15s ease-out;
        }
        
        .node-rect.selected {
            fill: #e0e0ff;
        }
        
        .node-text {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            text-anchor: middle;
            font-weight: 600;
        }
        
        .node-rect.playing {
            fill: #d0e7ff;
        }
        
        .node-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8px;
            fill: #666;
            font-weight: 400;
            pointer-events: none;
            text-anchor: middle;
        }
        
        .port {
            fill: #fff;
            stroke: #000;
            stroke-width: 2;
            cursor: pointer;
        }
        
        .port:hover {
            fill: #00f;
            stroke: #000;
            stroke-width: 2;
        }
        
        /* ================================================================
           PATCH VISUALIZATION STYLES
           Required by: lib/patch-viz.js
           ================================================================ */
        
        /* Connection lines: Always show yellow/black dashed pattern */
        .connection-path-yellow {
            stroke: #FFD700;
            stroke-width: 3;
            fill: none;
            pointer-events: none;
            stroke-dasharray: 8, 8;
        }
        
        .connection-path {
            stroke: #000;
            stroke-width: 3;
            fill: none;
            cursor: pointer;
            stroke-dasharray: 8, 8;
            stroke-dashoffset: 8;
        }
        
        .connection-path:hover {
            stroke: #000;
            stroke-width: 4;
        }
        
        .connection-path:hover + .connection-path-yellow,
        .connection-path-yellow.hover {
            stroke-width: 4;
        }
        
        /* Active state during playback: same style, just brighten yellow slightly */
        .connection-path.active,
        .connection-path.hover-active {
            stroke: #000;
            stroke-width: 3;
            stroke-dasharray: 8, 8;
            stroke-dashoffset: 8;
        }
        
        .connection-path-yellow.active,
        .connection-path-yellow.hover-active {
            stroke: #FFD700;
        }
        
        .node-rect.playing {
            fill: #fff;
            stroke: none;
        }
        
        .node-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            fill: #000;
            font-weight: 400;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .view-toggle {
            display: inline-flex;
            border: 1px solid #000;
            overflow: hidden;
        }
        
        .view-toggle button {
            padding: 6px 16px;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 12px;
        }
        
        .view-toggle button.active {
            background: #000;
            color: #fff;
        }
        
        .view-toggle button:hover:not(.active) {
            background: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="pa3 content-wrapper" style="max-width: 1100px; margin: 0 auto;">
        <h1 class="f1 mb2 mt0 tc" style="font-family: 'Lucida Blackletter', 'Blackletter686', serif; font-weight: normal;">DataSynth</h1>
        <p class="tc f6 gray mb3" style="max-width: 600px; margin-left: auto; margin-right: auto;">
            Turn any dataset into sound. <a href="https://github.com/luismqueral/data-2-sound" target="_blank" class="black underline">Learn More</a>
        </p>
        
        <!-- Data Selection -->
        <div class="mb4">
            <div class="tc mb2">
                <select id="templateSelector" class="pa2 ba b--black f6" style="width: 600px; max-width: 90%;">
                    <option value="">-- Select Dataset --</option>
                    
                    <optgroup label="üåç Earthquakes - All Magnitudes (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson">All Earthquakes: Past Hour (Real-time)</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson">All Earthquakes: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson">All Earthquakes: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson">All Earthquakes: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="üî¥ Earthquakes - Magnitude 4.5+ (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_hour.geojson">M4.5+: Past Hour</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson">M4.5+: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson">M4.5+: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_month.geojson">M4.5+: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="üü† Earthquakes - Magnitude 2.5+ (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_hour.geojson">M2.5+: Past Hour</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_day.geojson">M2.5+: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson">M2.5+: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_month.geojson">M2.5+: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="‚ö†Ô∏è Earthquakes - Significant Only (USGS Live)">
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_hour.geojson">Significant: Past Hour</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_day.geojson">Significant: Past Day</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_week.geojson">Significant: Past Week</option>
                        <option value="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.geojson">Significant: Past Month</option>
                    </optgroup>
                    
                    <optgroup label="üì¶ Earthquakes - Archived">
                        <option value="datasets/earthquakes-week.geojson">Local Archive: Weekly Snapshot (1600+ events)</option>
                    </optgroup>
                    
                    <optgroup label="üèóÔ∏è Urban Development">
                        <option value="datasets/Housing_and_Building_Permits_2019-Present.geojson">Baltimore Housing Permits (265K+ records)</option>
                    </optgroup>
                    
                    <optgroup label="üåå Space">
                        <option value="datasets/exoplanets.csv">NASA Exoplanets (6000+ planets)</option>
                        <option value="https://api.nasa.gov/neo/rest/v1/feed?start_date=2024-11-12&end_date=2024-11-12&api_key=DEMO_KEY">NASA: Near Earth Objects - Today</option>
                        <option value="http://api.open-notify.org/iss-now.json">ISS Location (Real-time)</option>
                        <option value="http://api.open-notify.org/astros.json">Astronauts in Space (Real-time)</option>
                    </optgroup>
                </select>
            </div>
            <div class="tc f6 gray mb3">
                Copy/paste or drag-and-drop dataset to upload your own
            </div>
            <div class="tc mb2">
                <span id="parseStatus" class="f6 gray"></span>
            </div>
            
            <div id="dropZone" class="drop-zone" style="display: none;">
                Drop JSON or CSV file here
            </div>
            
            <div id="customJsonContainer" style="display: none;">
                <textarea id="jsonEditor" spellcheck="false"></textarea>
                <div class="mt2">
                    <button id="closeEditorBtn" class="pa1 ba b--black bg-white pointer hover-bg-black hover-white f6">Close Editor</button>
                </div>
            </div>
            
            <!-- Data Table Modal -->
            <div id="dataTableModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 2px solid #000; padding: 20px; z-index: 2000; max-width: 90%; max-height: 80%; overflow: auto;">
                <div class="flex items-center justify-between mb3">
                    <h3 class="f4 ma0">Data Preview</h3>
                    <button id="closeTableBtn" class="pa1 ba b--black bg-white pointer hover-bg-black hover-white">Close</button>
                </div>
                <div style="max-height: 500px; overflow-y: auto;">
                    <table class="data-table">
                        <thead id="dataTableHead"></thead>
                        <tbody id="dataTableBody"></tbody>
                    </table>
                </div>
            </div>
            <div id="tableModalOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1999;"></div>
        </div>
        
        <!-- Control Buttons -->
        <div class="mb3 flex items-center justify-center">
            <button id="playDataBtn" disabled class="mr2 ba b--black bg-black white pointer hover-bg-white hover-black" style="width: 240px; padding: 16px 24px; font-size: 24px; height: 64px;">
                <span class="mr2" id="playIcon" style="font-size: 24px;">‚ñ∂</span>
                <span id="playText">Play Data</span>
            </button>
            <div class="mr2 ba b--black-10 flex items-center justify-center" id="itemLabel" style="background: #f5f5f5; padding: 16px 24px; min-width: 120px; height: 64px;">
                <div class="tc">
                    <div style="font-size: 9px; color: #999; letter-spacing: 0.5px; margin-bottom: 2px;">ITEM</div>
                    <div class="playback-value" id="itemValue" style="font-size: 16px; font-weight: 600; color: #000;">--</div>
                </div>
            </div>
            <button id="randomizeMappingsBtn" disabled class="ba b--black bg-white pointer hover-bg-black hover-white" style="padding: 16px 24px; font-size: 16px; min-width: 180px; height: 64px;">
                <span style="margin-right: 4px;">üîÄ</span>Randomize Patch
            </button>
        </div>
        
        <!-- Audio Visualizer -->
        <div style="margin-bottom: 20px;">
            <canvas id="audioVisualizer" style="width: 100%; height: 120px;"></canvas>
        </div>
        
        <!-- Global Settings Drawer -->
        <div class="settings-drawer">
            <div class="settings-drawer-header" id="settingsDrawerToggle">
                <span class="b f5">Global Settings</span>
                <span class="drawer-toggle" id="drawerToggleIcon">‚ñº</span>
            </div>
            <div class="settings-drawer-content" id="settingsDrawerContent">
                    
                    <div class="mb3" style="padding-bottom: 12px; border-bottom: 2px solid #ddd;">
                        <div class="b mb2 f6">Volume</div>
                        <label class="db mb2">
                            <span class="db mb1 f6">Master Volume:</span>
                            <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.2" class="w-100">
                            <span id="masterVolumeValue" class="f6">0.2 (20%)</span>
                        </label>
                        <label class="db mb2">
                            <span class="db mb1 f6">Master Pitch:</span>
                            <input type="range" id="pitchControl" min="-24" max="24" step="0.1" value="0" class="w-100">
                            <span id="pitchValue" class="f6">0 semitones</span>
                        </label>
                        <label class="db mb2">
                            <span class="db mb1 f6">Speed:</span>
                            <input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1" class="w-100">
                            <span id="speedValue" class="f6">1x</span>
                        </label>
                    </div>
                    
                    <div class="mb3" style="padding-bottom: 12px; border-bottom: 2px solid #ddd;">
                        <div class="b mb2 f6">Sound Source</div>
                        <label class="db mb2 f6">
                            <input type="radio" name="soundSource" value="synthesizer" checked class="mr2" id="synthesizerMode">
                            <span>üéπ Synthesizer (Oscillators)</span>
                        </label>
                        <label class="db mb2 f6">
                            <input type="radio" name="soundSource" value="sampler" class="mr2" id="samplerMode">
                            <span>üéµ Sampler (Audio Files)</span>
                        </label>
                        
                        <!-- Sample Upload Section (hidden by default) -->
                        <div id="sampleUploadSection" style="display: none; margin-top: 12px; padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">
                            <div class="mb2">
                                <label class="db mb1 f7 b">Load Audio Sample:</label>
                                <input type="file" id="sampleFileInput" accept="audio/wav,audio/mpeg,audio/mp3,audio/ogg,audio/webm,audio/x-m4a,audio/mp4,.wav,.mp3,.ogg,.webm,.m4a" class="f6 w-100" style="padding: 4px;">
                                <div class="f7 mt1" style="color: #666;">Best: WAV, MP3, OGG | M4A may need conversion</div>
                            </div>
                            
                            <!-- Sample Info Display -->
                            <div id="sampleInfo" style="display: none; margin-top: 8px; padding: 8px; background: white; border: 1px solid #ccc; border-radius: 3px;">
                                <div class="f7 mb1">
                                    <span class="b">üìÑ File:</span> <span id="sampleFileName">--</span>
                                </div>
                                <div class="f7 mb1">
                                    <span class="b">‚è± Duration:</span> <span id="sampleDuration">--</span>
                                </div>
                                <div class="f7 mb2">
                                    <span class="b">üìä Format:</span> <span id="sampleFormat">--</span>
                                </div>
                                
                                <!-- Random Chop Mode -->
                                <div style="padding: 6px 0; border-top: 1px solid #ddd; margin-bottom: 8px;">
                                    <label class="db f7 mt2">
                                        <input type="checkbox" id="randomChopMode" class="mr1">
                                        <span class="b">üé≤ Random Chop Mode</span>
                                    </label>
                                    <div class="f7 mt1" style="color: #666; line-height: 1.3;">
                                        Plays 5-second chunks starting from random 1-second intervals throughout the sample (ignores sampleOffset mapping)
                                    </div>
                                </div>
                                
                                <!-- Full Note Duration Mode -->
                                <div style="padding: 6px 0; border-top: 1px solid #ddd; margin-bottom: 8px;">
                                    <label class="db f7 mt2">
                                        <input type="checkbox" id="fullNoteDuration" class="mr1">
                                        <span class="b">üéµ Full Note Duration</span>
                                    </label>
                                    <div class="f7 mt1" style="color: #666; line-height: 1.3;">
                                        Sample plays for entire note duration instead of being cut by duration parameter (prevents early cutoffs)
                                    </div>
                                </div>
                                
                                <button id="clearSampleBtn" class="mt1 pa1 f7 ba b--black bg-white pointer hover-bg-black hover-white" style="width: 100%;">
                                    Clear Sample
                                </button>
                            </div>
                            
                            <div id="sampleLoadError" style="display: none; margin-top: 8px; padding: 8px; background: #ffe6e6; border: 1px solid #cc0000; border-radius: 3px; color: #cc0000; white-space: pre-line;" class="f7">
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb3">
                        <div class="b mb2 f6">Processing</div>
                        <label class="db mb2 f6">
                            <input type="checkbox" id="adaptiveNormalization" checked class="mr2">
                            <span>Adaptive Normalization</span>
                        </label>
                        <div class="f7 ml4 mb2" style="color: #666; line-height: 1.3; margin-top: -6px;">
                            Automatically balances data ranges for more consistent sound levels
                        </div>
                        <label class="db mb2 f6">
                            <input type="checkbox" id="rhythmicQuantization" class="mr2">
                            <span>Rhythmic Quantization</span>
                        </label>
                        <div class="f7 ml4 mb2" style="color: #666; line-height: 1.3; margin-top: -6px;">
                            Snaps note timings to a grid for tighter rhythms
                        </div>
                        <label class="db mb2 f6">
                            <input type="checkbox" id="pitchQuantization" checked class="mr2">
                            <span>Pitch Quantization (Scale)</span>
                        </label>
                        <div class="f7 ml4 mb2" style="color: #666; line-height: 1.3; margin-top: -6px;">
                            Constrains pitches to selected musical scale
                        </div>
                    </div>
                    
                    <div class="mb3" id="scaleContainer" style="display: none;">
                        <div class="b mb2 f6">Scale</div>
                        <select id="scaleSelector" class="w-100 pa1 ba b--black f6">
                            <option value="pentatonic" selected>Pentatonic (5 notes)</option>
                            <option value="major">Major Scale</option>
                            <option value="minor">Natural Minor</option>
                            <option value="dorian">Dorian Mode</option>
                            <option value="mixolydian">Mixolydian Mode</option>
                            <option value="chromatic">Chromatic (12 notes)</option>
                        </select>
                    </div>
                    
                    <div class="mb3" id="waveformSection">
                        <div class="b mb2 f6">Waveform</div>
                        <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #ddd;">
                            <div class="f7 mb1" style="color: #666;">Classic</div>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="sine" checked class="mr1"> Sine
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="square" class="mr1"> Square
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="sawtooth" class="mr1"> Sawtooth
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="triangle" class="mr1"> Triangle
                            </label>
                        </div>
                        <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #ddd;">
                            <div class="f7 mb1" style="color: #666;">Noise</div>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="white-noise" class="mr1"> White Noise
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="pink-noise" class="mr1"> Pink Noise
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="brown-noise" class="mr1"> Brown Noise
                            </label>
                        </div>
                        <div>
                            <div class="f7 mb1" style="color: #666;">Synthesis</div>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="fm" class="mr1"> FM Synthesis
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="additive" class="mr1"> Additive (Harmonics)
                            </label>
                            <label class="db mb1 f6">
                                <input type="radio" name="waveform" value="pwm" class="mr1"> Pulse Width Mod
                            </label>
                        </div>
                    </div>
                    
                    <div class="mb3" id="filterSection">
                        <div class="b mb2 f6">Filter</div>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="lowpass" checked class="mr1"> Lowpass
                        </label>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="highpass" class="mr1"> Highpass
                        </label>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="bandpass" class="mr1"> Bandpass
                        </label>
                        <label class="db mb1 f6">
                            <input type="radio" name="filterType" value="notch" class="mr1"> Notch
                        </label>
                    </div>
            </div>
        </div>
        
        <!-- Patch View (Full Width) -->
        <div class="bg-light-gray" style="padding: 20px; border: 1px solid #e0e0e0; margin-bottom: 20px;">
            <h3 class="f5 mt0 mb3">Patch View</h3>
            
            <div id="nodeView">
                <div style="position: relative;">
                    <div id="columnHeaders" style="position: relative; height: 20px; margin-bottom: 10px;">
                        <div id="leftHeader" style="position: absolute; font-family: 'IBM Plex Mono', monospace; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #666; transform: translateX(-50%);">Data Fields</div>
                        <div id="rightHeader" style="position: absolute; font-family: 'IBM Plex Mono', monospace; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #666; transform: translateX(-50%);">Audio Parameters</div>
                    </div>
                    <svg id="patchViz" width="100%" style="background: transparent;"></svg>
                </div>
            </div>
                    
            <div id="formView" style="display: none;">
                <h3 class="f5 mb3 b">Parameter Controls</h3>
                <div class="mb4">
                    <button id="randomizeMappingsBtn2" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize Mappings</button>
                    <button id="randomizeRangesBtn" disabled class="mr2 pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize Ranges</button>
                    <button id="randomizeAllBtn" disabled class="pa2 ba b--black bg-white pointer hover-bg-black hover-white">Randomize All</button>
                </div>
                <div id="mappingControls" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px 30px;"></div>
            </div>
        </div>
        
        <!-- Dataset Source Link -->
        <div class="tc mb4">
            <a id="datasetSourceLink" href="#" target="_blank" class="f7 gray underline" style="display: none;">View dataset source ‚Üí</a>
        </div>
    </div>
    
    <script type="module">
        // ============================================================================
        // MODULAR REFACTORING IN PROGRESS
        // ============================================================================
        // We're gradually extracting functions to ES6 modules.
        // Old inline functions remain temporarily for safety during migration.
        // Once verified working, old code will be removed.
        // ============================================================================
        
        // Import modules
        import { 
            getValueByPath, 
            safeId, 
            extractPaths,
            extractValues,
            analyzeDataVariance
        } from './lib/data-processor.js';
        
        import { AudioEngine } from './lib/audio-engine.js';
        import { ParameterMapper } from './lib/parameter-mapper.js';
        import { PatchViz } from './lib/patch-viz.js';
        
        console.log('=== data 2 sound starting (with ES6 modules) ===');
        console.log('‚úÖ Loaded data-processor.js module');
        console.log('‚úÖ Loaded audio-engine.js module');
        console.log('‚úÖ Loaded parameter-mapper.js module');
        console.log('‚úÖ Loaded patch-viz.js module');
        
        // Create global instances
        const audioEngine = new AudioEngine();
        const parameterMapper = new ParameterMapper();
        const patchViz = new PatchViz('patchViz');
        
        // Datasets are now loaded from /datasets folder via fetch()
        // No more hardcoded data in HTML
        
        const jsonEditor = document.getElementById('jsonEditor');
        
        // Auto-parse function
        function autoParseJSON() {
            const jsonText = jsonEditor.value.trim();
            const parseStatus = document.getElementById('parseStatus');
            const dataTableContainer = document.getElementById('dataTableContainer');
            
            if (!parseStatus) {
                console.error('parseStatus element not found');
                return false;
            }
            
            try {
                let data;
                
                // Detect if input is CSV (starts with non-bracket/brace characters and contains commas/newlines)
                const isLikelyCSV = !jsonText.startsWith('{') && !jsonText.startsWith('[') && 
                                   (jsonText.includes(',') || jsonText.split('\n').length > 1);
                
                if (isLikelyCSV) {
                    // Try parsing as CSV
                    console.log('Detected CSV format, parsing...');
                    data = d3.csvParse(jsonText, d3.autoType);
                    
                    if (!data || data.length === 0) {
                        throw new Error('CSV parsing resulted in empty data');
                    }
                    
                    console.log(`Parsed ${data.length} rows from CSV`);
                    parseStatus.textContent = `‚úì Parsed ${data.length} rows from CSV`;
                    parseStatus.style.color = '#00aa00';
                } else {
                    // Parse as JSON
                    data = JSON.parse(jsonText);
                    parseStatus.textContent = '';
                }
                
                console.log('Parsed data:', data);
                
                // Handle different JSON structures
                let processedData = data;
                
                // If single object with nested data, try to extract array
                if (!Array.isArray(data) && typeof data === 'object') {
                    // Look for array properties
                    const arrayProps = Object.keys(data).filter(key => Array.isArray(data[key]));
                    
                    if (arrayProps.length > 0) {
                        // Use first array found
                        processedData = data[arrayProps[0]];
                        console.log(`Found nested array at '${arrayProps[0]}' with ${processedData.length} items`);
                    } else {
                        // Look for object with many key-value pairs (like exchange rates)
                        const nestedObjects = Object.keys(data).filter(key => 
                            typeof data[key] === 'object' && data[key] !== null && !Array.isArray(data[key])
                        );
                        
                        if (nestedObjects.length > 0) {
                            // Convert first nested object to array of {key, value} pairs
                            const objKey = nestedObjects[0];
                            processedData = Object.entries(data[objKey]).map(([key, value]) => ({
                                key: key,
                                value: value
                            }));
                            console.log(`Converted nested object '${objKey}' to ${processedData.length} items`);
                        } else {
                            // Single object - wrap in array
                            processedData = [data];
                        }
                    }
                }
                
                parsedData = processedData;
                
                // Prepare table data (don't show yet - only when "View Data Table" is clicked)
                displayDataTable(Array.isArray(processedData) ? processedData : [processedData]);
                
                // Extract paths from processed data (not original)
                detectedPaths = extractPaths(processedData);
                numericPaths = detectedPaths.filter(p => p.type === 'number');
                
                console.log(`Data structure: ${Array.isArray(processedData) ? processedData.length + ' items' : 'single object'}`);
                console.log('First item sample:', Array.isArray(processedData) ? processedData[0] : processedData);
                
                console.log('Numeric paths found:', numericPaths.length);
                console.log('All numeric paths with coverage:', numericPaths.map(p => `${p.path} (${(p.coverage * 100).toFixed(0)}%)`));
                
                // Warn if no numeric paths found
                if (numericPaths.length === 0) {
                    console.warn('‚ö†Ô∏è NO NUMERIC PATHS FOUND!');
                    console.warn('This dataset may only contain strings/objects, or data is too deeply nested');
                    console.warn('All detected paths:', detectedPaths.map(p => `${p.path} (${p.type})`));
                    parseStatus.textContent = '‚ö†Ô∏è Warning: No numeric fields found in this dataset';
                    parseStatus.style.color = '#ff6600';
                }
                
                // Apply adaptive normalization if enabled
                const adaptiveCheckbox = document.getElementById('adaptiveNormalization');
                if (adaptiveCheckbox && adaptiveCheckbox.checked) {
                    const dataArray = Array.isArray(processedData) ? processedData : [processedData];
                    
                    numericPaths.forEach(pathObj => {
                        const values = extractValues(dataArray, pathObj.path);
                        const analysis = analyzeDataVariance(values);
                        
                        // Store recommended curve for this path
                        pathObj.recommendedCurve = analysis.curve;
                        pathObj.variance = analysis.coefficient;
                        
                        console.log(`${pathObj.path}: variance=${analysis.coefficient.toFixed(4)}, recommended=${analysis.curve}`);
                    });
                }
                
                // Create controls
                createMappingControls(numericPaths);
                
                // Enable buttons
                const playDataBtn = document.getElementById('playDataBtn');
                if (playDataBtn) playDataBtn.disabled = false;
                
                const randomizeBtn = document.getElementById('randomizeMappingsBtn');
                if (randomizeBtn) randomizeBtn.disabled = false;
                
                const randomizeBtn2 = document.getElementById('randomizeMappingsBtn2');
                if (randomizeBtn2) randomizeBtn2.disabled = false;
                
                const rangesBtn = document.getElementById('randomizeRangesBtn');
                if (rangesBtn) rangesBtn.disabled = false;
                
                const allBtn = document.getElementById('randomizeAllBtn');
                if (allBtn) allBtn.disabled = false;
                
                // Auto-apply smart mapping using parameter mapper
                parameterMapper.intelligentMapping(parsedData, numericPaths);
                mappings = parameterMapper.mappings; // Sync legacy object
                
                // Update UI form fields to reflect mappings
                Object.keys(mappings).forEach(paramId => {
                    const mapEl = document.getElementById(`map_${paramId}`);
                    const minEl = document.getElementById(`min_${paramId}`);
                    const maxEl = document.getElementById(`max_${paramId}`);
                    const curveEl = document.getElementById(`curve_${paramId}`);
                    
                    if (mapEl && mappings[paramId].path) mapEl.value = mappings[paramId].path;
                    if (minEl) minEl.value = mappings[paramId].min;
                    if (maxEl) maxEl.value = mappings[paramId].max;
                    if (curveEl) curveEl.value = mappings[paramId].curve;
                });
                
                // Update patch visualization to show mappings
                updatePatchVisualization();
                
                // Clear status (no need to show anything on success)
                parseStatus.textContent = '';
                
                return true;
            } catch (e) {
                console.error('Parse error:', e);
                const errorMsg = `‚úó Invalid JSON/CSV: ${e.message}`;
                parseStatus.textContent = errorMsg;
                parseStatus.style.color = '#cc0000';
                if (dataTableContainer) {
                    dataTableContainer.style.display = 'none';
                }
                return false;
            }
        }
        
        // Paste support - auto-parse on paste
        jsonEditor.addEventListener('paste', (e) => {
            setTimeout(() => {
                autoParseJSON();
            }, 100);
        });
        
        // Auto-parse on any content change (for manual edits)
        let parseTimeout;
        jsonEditor.addEventListener('input', (e) => {
            clearTimeout(parseTimeout);
            parseTimeout = setTimeout(() => {
                const text = jsonEditor.value.trim();
                // Trigger for JSON or CSV-like content
                if (text.startsWith('{') || text.startsWith('[') || (text.includes(',') && text.split('\n').length > 1)) {
                    autoParseJSON();
                }
            }, 1000); // Wait 1 second after typing stops
        });
        
        // Template selector - load from datasets folder
        document.getElementById('templateSelector').addEventListener('change', async (e) => {
            const filePath = e.target.value;
            if (!filePath) {
                // Clear source link if no selection
                document.getElementById('datasetSourceLink').style.display = 'none';
                return;
            }
            
            const parseStatus = document.getElementById('parseStatus');
            parseStatus.textContent = 'Loading...';
            parseStatus.style.color = '#666';
            
            // Show/update dataset source link
            const sourceLink = document.getElementById('datasetSourceLink');
            sourceLink.href = filePath;
            sourceLink.style.display = 'inline';
            
            try {
                // Add cache-busting for APIs to get fresh data
                const isAPI = filePath.startsWith('http://') || filePath.startsWith('https://');
                const fetchURL = isAPI ? `${filePath}${filePath.includes('?') ? '&' : '?'}_t=${Date.now()}` : filePath;
                
                const response = await fetch(fetchURL, {
                    cache: 'no-cache', // Force fresh data
                    headers: isAPI ? {} : undefined
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to load file: ${response.statusText}`);
                }
                
                const contentType = response.headers.get('content-type');
                const text = await response.text();
                
                // Detect file type and load accordingly
                if (filePath.endsWith('.csv')) {
                    // CSV file - load directly into editor
                    jsonEditor.value = text;
                    console.log(`Loaded CSV: ${filePath}`);
                } else if (filePath.endsWith('.json')) {
                    // JSON file - prettify for editor
                    const json = JSON.parse(text);
                    jsonEditor.value = JSON.stringify(json, null, 2);
                    console.log(`Loaded JSON: ${filePath}, items:`, Array.isArray(json) ? json.length : 'object');
                } else if (filePath.endsWith('.geojson')) {
                    // GeoJSON file - prettify for editor
                    const geojson = JSON.parse(text);
                    jsonEditor.value = JSON.stringify(geojson, null, 2);
                    console.log(`Loaded GeoJSON: ${filePath}, features:`, geojson.features?.length || 'N/A');
                }
                
                // Auto-parse after loading
                setTimeout(() => autoParseJSON(), 100);
            } catch (error) {
                console.error('Error loading dataset:', error);
                parseStatus.textContent = `‚úó Error loading file: ${error.message}`;
                parseStatus.style.color = '#cc0000';
            }
        });
        
        // Drag-and-drop file upload
        const dropZone = document.getElementById('dropZone');
        const body = document.body;
        
        // Show drop zone when dragging files over window
        body.addEventListener('dragenter', (e) => {
            e.preventDefault();
            if (e.dataTransfer.types.includes('Files')) {
                dropZone.style.display = 'block';
            }
        });
        
        body.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            if (e.target === dropZone) {
                dropZone.classList.remove('drag-over');
                dropZone.style.display = 'none';
            }
        });
        
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            dropZone.style.display = 'none';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const fileName = file.name.toLowerCase();
                
                console.log('Dropped file:', file.name, 'Type:', file.type);
                
                const parseStatus = document.getElementById('parseStatus');
                parseStatus.textContent = `Loading ${file.name}...`;
                parseStatus.style.color = '#666';
                
                try {
                    const text = await file.text();
                    
                    // Clear dropdown selection and source link
                    document.getElementById('templateSelector').value = '';
                    document.getElementById('datasetSourceLink').style.display = 'none';
                    
                    // Load into editor
                    if (fileName.endsWith('.json') || fileName.endsWith('.geojson')) {
                        const json = JSON.parse(text);
                        jsonEditor.value = JSON.stringify(json, null, 2);
                        console.log('Loaded JSON file:', fileName);
                    } else if (fileName.endsWith('.csv')) {
                        jsonEditor.value = text;
                        console.log('Loaded CSV file:', fileName);
                    } else {
                        // Try as JSON/CSV
                        jsonEditor.value = text;
                        console.log('Loaded file:', fileName);
                    }
                    
                    // Auto-parse
                    setTimeout(() => autoParseJSON(), 100);
                } catch (error) {
                    console.error('Error reading file:', error);
                    parseStatus.textContent = `‚úó Error reading file: ${error.message}`;
                    parseStatus.style.color = '#cc0000';
                }
            }
        });
        
        body.addEventListener('dragleave', (e) => {
            if (e.target === body) {
                dropZone.classList.remove('drag-over');
                dropZone.style.display = 'none';
            }
        });
        
        body.addEventListener('drop', (e) => {
            // Prevent default for any drop outside dropZone
            if (e.target !== dropZone && !dropZone.contains(e.target)) {
                e.preventDefault();
                dropZone.style.display = 'none';
            }
        });
        
        // Global paste support - paste anywhere on page
        document.addEventListener('paste', async (e) => {
            // Check if pasting into textarea already
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                return; // Let default paste behavior happen
            }
            
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text');
            
            if (pastedText && pastedText.trim()) {
                console.log('Pasted data detected, length:', pastedText.length);
                
                // Clear dropdown selection and source link
                document.getElementById('templateSelector').value = '';
                document.getElementById('datasetSourceLink').style.display = 'none';
                
                // Load into editor
                jsonEditor.value = pastedText;
                
                // Auto-parse
                setTimeout(() => autoParseJSON(), 100);
            }
        });
        
        // Settings drawer toggle
        document.getElementById('settingsDrawerToggle').addEventListener('click', () => {
            const content = document.getElementById('settingsDrawerContent');
            const icon = document.getElementById('drawerToggleIcon');
            
            content.classList.toggle('open');
            icon.classList.toggle('open');
        });
        
        // Auto-load default template on page load
        setTimeout(async () => {
            console.log('Auto-loading default dataset...');
            const templateSelector = document.getElementById('templateSelector');
            if (templateSelector) {
                templateSelector.value = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson';
                // Trigger the change event to load the file
                templateSelector.dispatchEvent(new Event('change'));
            }
        }, 100);

        // View toggle (Node vs Form)
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const viewName = e.target.dataset.view;
                
                // Update active button
                document.querySelectorAll('.view-toggle-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                // Toggle views
                if (viewName === 'node') {
                    document.getElementById('nodeView').style.display = 'block';
                    document.getElementById('formView').style.display = 'none';
                } else {
                    document.getElementById('nodeView').style.display = 'none';
                    document.getElementById('formView').style.display = 'block';
                }
            });
        });

        // Manual parse button (for re-parsing after edits)
        document.getElementById('parseDataBtn')?.addEventListener('click', () => {
            autoParseJSON();
        });

        // Display data in table format
        function displayDataTable(data) {
            if (data.length === 0) return;
            
            const head = document.getElementById('dataTableHead');
            const body = document.getElementById('dataTableBody');
            
            if (!head || !body) return;
            
            // Get all keys
            const keys = Object.keys(data[0]);
            
            // Create header
            head.innerHTML = '<tr>' + keys.map(k => `<th>${k}</th>`).join('') + '</tr>';
            
            // Create rows (limit to first 50 for performance)
            body.innerHTML = '';
            const displayData = data.slice(0, 50);
            displayData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = keys.map(k => `<td>${row[k]}</td>`).join('');
                body.appendChild(tr);
            });
            
            if (data.length > 50) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="${keys.length}" style="text-align: center; color: #666;">... ${data.length - 50} more rows ...</td>`;
                body.appendChild(tr);
            }
        }

        // ============================================================================
        // DATA FLOW DOCUMENTATION
        // ============================================================================
        // 
        // 1. DATA LOADING & PARSING
        //    - User selects dataset from dropdown OR drags/pastes data
        //    - autoParseJSON() detects format (JSON/CSV/GeoJSON)
        //    - For GeoJSON: extracts data.features array automatically
        //    - For nested JSON: finds first array property and extracts it
        //    - Result stored in: parsedData (always an array of objects)
        //
        // 2. PATH EXTRACTION & VALIDATION
        //    - extractPaths() recursively walks first item to find all field paths
        //    - Samples up to 20 items to verify field exists across dataset
        //    - Calculates coverage % (how many items have each field)
        //    - Filters out sparse fields (<10% coverage) to avoid null issues
        //    - Separates numeric vs string paths
        //    - Result stored in: detectedPaths, numericPaths
        //
        // 3. VISUALIZATION SETUP
        //    - createNodes() builds node list from numericPaths
        //    - Data nodes (left): one per numeric field with safeId(path)
        //    - Audio nodes (right): one per audio parameter (13 total)
        //    - drawNodes() renders SVG with D3, creates DOM elements
        //    - Each node gets text element with ID: value_${safeId}
        //
        // 4. MAPPING (Smart or Manual)
        //    - Smart mapping analyzes variance/uniqueness to rank "interestingness"
        //    - Assigns best data paths to perceptually important audio params
        //    - Stores in mappings object: { audioParam: { path, min, max, curve } }
        //
        // 5. PLAYBACK & SONIFICATION
        //    - Loops through parsedData array, one item per iteration
        //    - For each item: getValueByPath() extracts values using dot notation
        //    - Values scaled from data range to audio parameter range
        //    - Curve transformations applied (linear/exponential/cubic/log/inverse)
        //    - Web Audio API generates sound with calculated parameters
        //    - updateNodeValues() called to update D3 visualization
        //
        // 6. VISUALIZATION UPDATE (D3)
        //    - For each node, looks up value using getValueByPath()
        //    - Updates text content of DOM element via d3.select()
        //    - Highlights active nodes (green border) if path is mapped
        //    - Shows "--" if value is null/undefined for that item
        //
        // ============================================================================
        
        // ============================================================================
        // GLOBAL STATE
        // ============================================================================
        // Data state (remains as global variables for now)
        let parsedData = null;         // Array of data items (after extraction from GeoJSON/nested structures)
        let detectedPaths = [];        // All detected field paths with type info and coverage %
        let numericPaths = [];         // Filtered list of only numeric paths
        let mappings = {};             // Current data-to-audio mappings { audioParam: { path, min, max, curve } }
        
        // Playback state (remains as global variables)
        let isPlaying = false;         // Playback state
        let isPaused = false;          // Pause state
        let currentTimeout;            // For note timing
        
        // Audio state - NOW MANAGED BY audioEngine instance
        // Access via: audioEngine.audioContext, audioEngine.delayNode, etc.
        // Legacy references for compatibility during migration:
        let audioContext;              // ‚Üí audioEngine.audioContext
        let delayNode, delayFeedbackGain, delayWetGain, delayDryGain;  // ‚Üí audioEngine.*
        let reverbNode, reverbWetGain, reverbDryGain;                   // ‚Üí audioEngine.*
        let previousDelayTime = null;  // ‚Üí audioEngine.previousDelayTime
        let samplerMode = false;       // ‚Üí audioEngine.samplerMode
        let sampleBuffer = null;       // ‚Üí audioEngine.sampleBuffer
        let sampleFileName = '';       // ‚Üí audioEngine.sampleFileName
        let sampleDuration = 0;        // ‚Üí audioEngine.sampleDuration

        // Master Volume control
        document.getElementById('masterVolume').addEventListener('input', (e) => {
            const vol = parseFloat(e.target.value);
            document.getElementById('masterVolumeValue').textContent = `${vol.toFixed(2)} (${(vol * 100).toFixed(0)}%)`;
        });
        
        // Sound Source mode toggle (Synthesizer vs Sampler)
        document.querySelectorAll('input[name="soundSource"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                samplerMode = e.target.value === 'sampler';
                audioEngine.samplerMode = samplerMode; // Sync with engine
                parameterMapper.samplerMode = samplerMode; // Sync with mapper
                
                const uploadSection = document.getElementById('sampleUploadSection');
                const waveformSection = document.getElementById('waveformSection');
                const filterSection = document.getElementById('filterSection');
                
                uploadSection.style.display = samplerMode ? 'block' : 'none';
                // Hide waveform and filter controls in sampler mode (not applicable)
                waveformSection.style.display = samplerMode ? 'none' : 'block';
                filterSection.style.display = samplerMode ? 'none' : 'block';
                
                console.log(`üéõÔ∏è Switched to ${samplerMode ? 'SAMPLER' : 'SYNTHESIZER'} mode`);
                
                // Rebuild parameter UI and patch visualization with new parameter set
                if (numericPaths.length > 0) {
                    createMappingControls(numericPaths);
                    updatePatchVisualization();
                    console.log('‚úÖ UI rebuilt for new mode');
                }
            });
        });
        
        // Sample file upload handler
        document.getElementById('sampleFileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log(`üìÇ Loading sample: ${file.name} (${file.type || 'unknown type'})`);
            
            // Hide error, show loading state
            document.getElementById('sampleLoadError').style.display = 'none';
            document.getElementById('sampleInfo').style.display = 'none';
            
            try {
                // Use audio engine to load sample
                const sampleInfo = await audioEngine.loadSample(file);
                
                // Sync legacy variables
                sampleBuffer = audioEngine.sampleBuffer;
                sampleFileName = audioEngine.sampleFileName;
                sampleDuration = audioEngine.sampleDuration;
                audioContext = audioEngine.audioContext;
                
                // Display sample info
                document.getElementById('sampleFileName').textContent = sampleInfo.fileName;
                document.getElementById('sampleDuration').textContent = `${sampleInfo.duration.toFixed(2)}s`;
                document.getElementById('sampleFormat').textContent = 
                    `${sampleInfo.channels} ch, ${(sampleInfo.sampleRate / 1000).toFixed(1)} kHz`;
                document.getElementById('sampleInfo').style.display = 'block';
                
            } catch (error) {
                console.error('‚ùå Error loading sample:', error);
                
                // Display error message
                let errorMsg = error.message;
                
                // Add conversion guidance for M4A
                if (errorMsg.includes('M4A')) {
                    errorMsg += `

Free online converters: CloudConvert.com, FreeConvert.com
Or use audio software like Audacity (free).`;
                }
                
                document.getElementById('sampleLoadError').textContent = errorMsg;
                document.getElementById('sampleLoadError').style.display = 'block';
            }
        });
        
        // Clear sample button
        document.getElementById('clearSampleBtn').addEventListener('click', () => {
            audioEngine.clearSample();
            
            // Sync legacy variables
            sampleBuffer = null;
            sampleFileName = '';
            sampleDuration = 0;
            
            document.getElementById('sampleFileInput').value = '';
            document.getElementById('sampleInfo').style.display = 'none';
        });
        
        // Speed control
        document.getElementById('speedControl').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = `${e.target.value}x`;
        });
        
        // Pitch control
        document.getElementById('pitchControl').addEventListener('input', (e) => {
            const semitones = parseFloat(e.target.value);
            const sign = semitones >= 0 ? '+' : '';
            document.getElementById('pitchValue').textContent = `${sign}${semitones.toFixed(1)} semitones`;
        });
        
        // Pitch quantization toggle - show/hide scale selector
        const pitchQuantCheckbox = document.getElementById('pitchQuantization');
        const scaleContainer = document.getElementById('scaleContainer');
        
        // Show scale selector if pitch quantization is checked on load
        if (pitchQuantCheckbox.checked) {
            scaleContainer.style.display = 'block';
        }
        
        pitchQuantCheckbox.addEventListener('change', (e) => {
            scaleContainer.style.display = e.target.checked ? 'block' : 'none';
        });

        // ============================================================================
        // AUDIO SYNTHESIS FUNCTIONS - NOW IMPORTED FROM MODULE
        // ============================================================================
        // These functions are now methods of AudioEngine class in lib/audio-engine.js
        // Old inline definitions removed - using engine instance methods
        // ============================================================================
        
        // ============================================================================
        // DATA PROCESSING FUNCTIONS - NOW IMPORTED FROM MODULE
        // ============================================================================
        // These functions are now loaded from lib/data-processor.js (see imports above)
        // Old inline definitions removed - using module versions
        // ============================================================================
        
        // Rhythmic Quantization - snap to musical grid
        function quantizeRhythm(spacing) {
            // Musical time divisions (in ms at 120 BPM)
            const rhythmGrid = [
                125,   // 32nd note
                250,   // 16th note
                375,   // Dotted 16th
                500,   // 8th note
                750,   // Dotted 8th
                1000,  // Quarter note
                1500,  // Dotted quarter
                2000   // Half note
            ];
            
            // Find nearest grid value
            return rhythmGrid.reduce((prev, curr) => 
                Math.abs(curr - spacing) < Math.abs(prev - spacing) ? curr : prev
            );
        }
        
        // Pitch Quantization - snap to musical scales
        function quantizePitch(frequency) {
            const scaleType = document.getElementById('scaleSelector')?.value || 'pentatonic';
            
            // Define scales as MIDI note offsets from C (within one octave)
            const scales = {
                pentatonic: [0, 2, 4, 7, 9], // C D E G A
                major: [0, 2, 4, 5, 7, 9, 11], // C D E F G A B
                minor: [0, 2, 3, 5, 7, 8, 10], // C D Eb F G Ab Bb
                dorian: [0, 2, 3, 5, 7, 9, 10], // C D Eb F G A Bb
                mixolydian: [0, 2, 4, 5, 7, 9, 10], // C D E F G A Bb
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] // All 12 notes
            };
            
            const scale = scales[scaleType] || scales.pentatonic;
            
            // Convert frequency to MIDI note number
            const midiNote = 69 + 12 * Math.log2(frequency / 440);
            
            // Find base octave and note within octave
            const octave = Math.floor(midiNote / 12);
            const noteInOctave = midiNote % 12;
            
            // Find closest scale degree
            let closestScaleDegree = scale[0];
            let minDistance = Math.abs(noteInOctave - closestScaleDegree);
            
            for (const degree of scale) {
                const distance = Math.abs(noteInOctave - degree);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestScaleDegree = degree;
                }
            }
            
            // Reconstruct MIDI note in scale
            const quantizedMidi = octave * 12 + closestScaleDegree;
            
            // Convert back to frequency
            const quantizedFrequency = 440 * Math.pow(2, (quantizedMidi - 69) / 12);
            
            return quantizedFrequency;
        }

        // ============================================================================
        // PARAMETER CONFIGURATION - NOW IN PARAMETER-MAPPER MODULE
        // ============================================================================
        // getAudioParams() ‚Üí parameterMapper.getAudioParams()
        // ============================================================================
        
        // Create mapping controls
        function createMappingControls(numericPaths) {
            const mappingControls = document.getElementById('mappingControls');
            mappingControls.innerHTML = '';
            
            const audioParams = parameterMapper.getAudioParams();
            
            audioParams.forEach(param => {
                const div = document.createElement('div');
                div.className = 'bg-black-05 pa2';
                div.innerHTML = `
                    <div class="b mb2 f6">${param.label}</div>
                    <label class="db mb2">
                        <span class="db mb1">Path:</span>
                        <select id="map_${param.id}" class="w-100 pa1 ba b--black-20 f6">
                            <option value="">-- Fixed --</option>
                            ${numericPaths.map(p => `<option value="${p.path}">${p.path}</option>`).join('')}
                        </select>
                    </label>
                    <div class="flex items-center mb2">
                        <label class="mr2 flex-auto">
                            <span class="db mb1">Fixed:</span>
                            <input type="number" id="fixed_${param.id}" value="${param.default}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                        <label class="mr2 flex-auto">
                            <span class="db mb1">Min:</span>
                            <input type="number" id="min_${param.id}" value="${param.min}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                        <label class="flex-auto">
                            <span class="db mb1">Max:</span>
                            <input type="number" id="max_${param.id}" value="${param.max}" step="any" class="w-100 pa1 ba b--black-20 f6">
                        </label>
                    </div>
                    <label class="db">
                        <span class="db mb1">Curve:</span>
                        <select id="curve_${param.id}" class="w-100 pa1 ba b--black-20 f6">
                            <option value="linear">Linear</option>
                            <option value="exponential">Exponential</option>
                            <option value="cubic">Cubic</option>
                            <option value="logarithmic">Logarithmic</option>
                            <option value="inverse">Inverse</option>
                        </select>
                    </label>
                `;
                mappingControls.appendChild(div);
                
                // Initialize mapping in parameterMapper and sync with legacy mappings object
                parameterMapper.mappings[param.id] = {
                    path: '',
                    fixed: param.default,
                    min: param.min,
                    max: param.max,
                    curve: 'linear'
                };
                mappings[param.id] = parameterMapper.mappings[param.id]; // Sync reference
                
                document.getElementById(`map_${param.id}`).addEventListener('change', (e) => {
                    mappings[param.id].path = e.target.value;
                    updatePatchVisualization();
                });
                
                document.getElementById(`fixed_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].fixed = parseFloat(e.target.value);
                });
                
                document.getElementById(`min_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].min = parseFloat(e.target.value);
                });
                
                document.getElementById(`max_${param.id}`).addEventListener('input', (e) => {
                    mappings[param.id].max = parseFloat(e.target.value);
                });
                
                document.getElementById(`curve_${param.id}`).addEventListener('change', (e) => {
                    mappings[param.id].curve = e.target.value;
                });
            });
            
            updatePatchVisualization();
        }

        // ============================================================================
        // INTELLIGENT MAPPING & RANDOMIZATION - NOW IN PARAMETER-MAPPER MODULE
        // ============================================================================
        // intelligentMapping() ‚Üí parameterMapper.intelligentMapping()
        // randomizeMappings() ‚Üí parameterMapper.randomizeMappings()
        // randomizeRanges() ‚Üí parameterMapper.randomizeRanges()
        // randomizeAll() ‚Üí parameterMapper.randomizeAll()
        // Old inline definitions removed - using mapper instance methods
        // ============================================================================

        document.getElementById('randomizeMappingsBtn').addEventListener('click', () => {
            parameterMapper.randomizeMappings(numericPaths);
            mappings = parameterMapper.mappings; // Sync legacy object
            updatePatchVisualization();
            
            // Randomize waveform and filter too
            const waveforms = ['sine', 'square', 'sawtooth', 'triangle'];
            const waveformEl = document.querySelector(`input[name="waveform"][value="${parameterMapper._randomElement(waveforms)}"]`);
            if (waveformEl) waveformEl.checked = true;
            
            const filterTypes = ['lowpass', 'highpass', 'bandpass', 'notch'];
            const filterEl = document.querySelector(`input[name="filterType"][value="${parameterMapper._randomElement(filterTypes)}"]`);
            if (filterEl) filterEl.checked = true;
        });
        
        document.getElementById('randomizeMappingsBtn2')?.addEventListener('click', () => {
            parameterMapper.randomizeMappings(numericPaths);
            mappings = parameterMapper.mappings; // Sync
            updatePatchVisualization();
        });
        
        document.getElementById('randomizeRangesBtn')?.addEventListener('click', () => {
            parameterMapper.randomizeRanges();
            mappings = parameterMapper.mappings; // Sync
            
            // Update UI form fields
            Object.keys(mappings).forEach(paramId => {
                const minEl = document.getElementById(`min_${paramId}`);
                const maxEl = document.getElementById(`max_${paramId}`);
                if (minEl) minEl.value = mappings[paramId].min.toFixed(2);
                if (maxEl) maxEl.value = mappings[paramId].max.toFixed(2);
                });
            });
            
        document.getElementById('randomizeAllBtn')?.addEventListener('click', () => {
            parameterMapper.randomizeAll(numericPaths);
            mappings = parameterMapper.mappings; // Sync
            updatePatchVisualization();
        });

        // ============================================================================
        // PATCH VISUALIZATION - NOW IN PATCH-VIZ MODULE
        // ============================================================================
        // Wrapper functions for backward compatibility
        // These delegate to PatchViz module methods
        function updatePatchVisualization() {
            patchViz.render(numericPaths, mappings, parameterMapper, isPlaying);
            nodes = patchViz.nodes; // Sync legacy reference
        }
        
        function updateNodeValues(currentItem, calculatedAudioParams) {
            patchViz.updateNodeValues(currentItem, calculatedAudioParams, mappings, isPlaying);
            nodes = patchViz.nodes; // Sync legacy reference
        }
        
        function clearNodeValues() {
            patchViz.clearNodeValues();
        }
        
        // Legacy node reference (synced with patchViz.nodes after render)
        let nodes = [];
        
        // ============================================================================
        // EFFECTS & VISUALIZER FUNCTIONS - NOW IN AUDIO ENGINE MODULE
        // ============================================================================
        // createReverbImpulse() ‚Üí audioEngine.createReverbImpulse()
        // initEffects() ‚Üí audioEngine.initEffects()
        // setupVisualizer() ‚Üí audioEngine.setupVisualizer()
        // drawVisualizer() ‚Üí audioEngine.drawVisualizer()
        // ============================================================================
        
        // Get canvas element for visualizer (will be passed to engine)
        const visualizerCanvas = document.getElementById('audioVisualizer');
        
        // Legacy variables for compatibility (synced with engine)
        let analyser, dataArray, animationId;

        // Audio playback with looping
        async function playDataSonification() {
            if (!parsedData) return;
            
            // Handle stop (button acts as toggle)
            if (isPlaying) {
                stopPlayback();
                return;
            }
            
            // Start playback
            isPlaying = true;
            isPaused = false;
            audioEngine.previousDelayTime = null; // Reset for fresh start
            document.getElementById('playIcon').textContent = '‚èπ';
            document.getElementById('playText').textContent = 'Stop';
            visualizerCanvas.classList.add('active');
            
            // Initialize effects if not already set up (may have audioContext from sample loading)
            if (!audioEngine.delayNode) {
                audioEngine.initEffects();
                // Sync legacy variables
                audioContext = audioEngine.audioContext;
                delayNode = audioEngine.delayNode;
                delayFeedbackGain = audioEngine.delayFeedbackGain;
                delayWetGain = audioEngine.delayWetGain;
                delayDryGain = audioEngine.delayDryGain;
                reverbNode = audioEngine.reverbNode;
                reverbWetGain = audioEngine.reverbWetGain;
                reverbDryGain = audioEngine.reverbDryGain;
            }
            
            // Setup or reconnect visualizer
            if (!audioEngine.analyser) {
                audioEngine.setupVisualizer(visualizerCanvas);
                // Sync legacy variables
                analyser = audioEngine.analyser;
                dataArray = audioEngine.dataArray;
            }
            
            // Start visualizer animation
            animationId = audioEngine.drawVisualizer(isPlaying);
            
            // Reset debug flags for new playback
            patchViz.resetDebugFlags();
            
            // Convert to array if single object (renamed to avoid collision with visualizer dataArray)
            const itemsArray = Array.isArray(parsedData) ? parsedData : [parsedData];
            
            console.log('=== Playback Starting ===');
            console.log('Data items:', itemsArray.length);
            console.log('First item in data:', itemsArray[0]);
            
            // Calculate data ranges for all mapped parameters ONCE
            const dataRanges = {};
            Object.entries(mappings).forEach(([param, mapping]) => {
                if (mapping && mapping.path) {
                    const values = itemsArray.map(item => getValueByPath(item, mapping.path))
                        .filter(v => v !== undefined && !isNaN(parseFloat(v)))
                        .map(v => parseFloat(v));
                    
                    if (values.length > 0) {
                        dataRanges[param] = {
                            min: Math.min(...values),
                            max: Math.max(...values)
                        };
                    }
                }
            });
            
            console.log('Data ranges:', dataRanges);
            
            // Log active mappings
            console.log('=== Active Mappings ===');
            Object.keys(mappings).forEach(param => {
                if (mappings[param].path) {
                    console.log(`‚úì ${param}: ${mappings[param].path} [${mappings[param].min} to ${mappings[param].max}] (${mappings[param].curve})`);
                }
            });
            console.log('======================');
            
            // Loop continuously
            while (isPlaying) {
                for (let i = 0; i < itemsArray.length && isPlaying; i++) {
                    // Wait if paused
                    while (isPaused && isPlaying) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    if (!isPlaying) break;
                    
                    const item = itemsArray[i];
                    
                    // Helper to calculate mapped parameter value with curve scaling
                    const getParamValue = (paramName) => {
                        const mapping = mappings[paramName];
                        if (!mapping) return null;
                        
                        if (mapping.path && dataRanges[paramName]) {
                            const rawValue = parseFloat(getValueByPath(item, mapping.path));
                            if (isNaN(rawValue)) return mapping.fixed;
                            
                            // Scale from actual data range to audio parameter range
                            const dataMin = dataRanges[paramName].min;
                            const dataMax = dataRanges[paramName].max;
                            
                            if (dataMax === dataMin) return mapping.min;
                            
                            let normalized = (rawValue - dataMin) / (dataMax - dataMin);
                            normalized = Math.max(0, Math.min(1, normalized));
                            
                            // Apply curve transformation
                            let curved = normalized;
                            switch (mapping.curve) {
                                case 'exponential':
                                    curved = Math.pow(normalized, 2);
                                    break;
                                case 'cubic':
                                    curved = Math.pow(normalized, 3);
                                    break;
                                case 'logarithmic':
                                    curved = normalized > 0 ? Math.log(1 + normalized * 9) / Math.log(10) : 0;
                                    break;
                                case 'inverse':
                                    curved = 1 - normalized;
                                    break;
                                case 'linear':
                                default:
                                    curved = normalized;
                                    break;
                            }
                            
                            // Apply to audio range
                            return mapping.min + (curved * (mapping.max - mapping.min));
                        }
                        return mapping.fixed;
                    };
                    
                    // Calculate all audio parameters (mode-specific)
                    const audioParams = {};
                    
                    if (samplerMode) {
                        // Sampler mode: pitch (playback rate) and sampleOffset
                        audioParams.pitch = getParamValue('pitch');
                        audioParams.sampleOffset = getParamValue('sampleOffset');
                    } else {
                        // Synthesizer mode: frequency
                        const frequency = getParamValue('frequency') || 440;
                        audioParams.frequency = frequency;
                    }
                    
                    // Common parameters for both modes
                    audioParams.duration = getParamValue('duration');
                    audioParams.noteSpacing = getParamValue('noteSpacing');
                    audioParams.pan = getParamValue('pan');
                    audioParams.filterFreq = getParamValue('filterFreq');
                    audioParams.filterQ = getParamValue('filterQ');
                    audioParams.delayTime = getParamValue('delayTime');
                    audioParams.delayFeedback = getParamValue('delayFeedback');
                    audioParams.delayMix = getParamValue('delayMix');
                    audioParams.reverbDecay = getParamValue('reverbDecay');
                    audioParams.reverbMix = getParamValue('reverbMix');
                    audioParams.attack = getParamValue('attack');
                    audioParams.release = getParamValue('release');
                    
                    // Update node visualization
                    updateNodeValues(item, audioParams);
                    
                    // Get all audio parameters (use defaults if not mapped)
                    const volume = parseFloat(document.getElementById('masterVolume')?.value || 0.2);
                    const duration = audioParams.duration || 200;
                    const pan = audioParams.pan || 0;
                    const filterFreq = audioParams.filterFreq || 2000;
                    const filterQ = audioParams.filterQ || 1;
                    const attack = audioParams.attack || 10;
                    const release = audioParams.release || 100;
                    
                    // Update delay parameters globally with analog-style pitch shifting
                    let delayTime = audioParams.delayTime || 200;
                    const delayFeedback = audioParams.delayFeedback !== null && audioParams.delayFeedback !== undefined ? audioParams.delayFeedback : 0.3;
                    const delayMix = audioParams.delayMix !== null && audioParams.delayMix !== undefined ? audioParams.delayMix : 0.3;
                    
                    // Add subtle random variation to delay time for organic pitch-shifting layers (¬±15%)
                    const delayTimeVariation = 0.85 + (Math.random() * 0.3); // 0.85 to 1.15 multiplier
                    delayTime = delayTime * delayTimeVariation;
                    
                    if (delayNode && delayFeedbackGain && delayWetGain && delayDryGain) {
                        const now = audioContext.currentTime;
                        const newDelayTimeSeconds = Math.max(0.001, Math.min(2, delayTime / 1000));
                        
                        // Analog delay pitch shifting: when delay time changes, ramp smoothly (creates pitch bend)
                        if (audioEngine.previousDelayTime !== null && Math.abs(newDelayTimeSeconds - audioEngine.previousDelayTime) > 0.005) {
                            // Fast ramp creates pitch shifting effect (like tape speed change)
                            const rampTime = 0.05; // 50ms ramp creates audible pitch shift
                            try {
                                delayNode.delayTime.cancelScheduledValues(now);
                                delayNode.delayTime.setValueAtTime(audioEngine.previousDelayTime, now);
                                delayNode.delayTime.linearRampToValueAtTime(newDelayTimeSeconds, now + rampTime);
                                
                                // Log first analog shift for debugging
                                if (i === 0) {
                                    console.log(`üéõÔ∏è Analog delay shift: ${(audioEngine.previousDelayTime * 1000).toFixed(0)}ms ‚Üí ${delayTime.toFixed(0)}ms (pitch bend)`);
                                }
                            } catch (e) {
                                console.warn('Delay ramp error:', e);
                                delayNode.delayTime.setValueAtTime(newDelayTimeSeconds, now);
                            }
                        } else {
                            delayNode.delayTime.setValueAtTime(newDelayTimeSeconds, now);
                        }
                        audioEngine.previousDelayTime = newDelayTimeSeconds;
                        previousDelayTime = audioEngine.previousDelayTime; // Sync legacy var
                        
                        // Update feedback and mix globally
                        const safeFeedback = Math.max(0, Math.min(0.9, delayFeedback));
                        const safeMix = Math.max(0, Math.min(1, delayMix));
                        
                        delayFeedbackGain.gain.setValueAtTime(safeFeedback, now);
                        delayWetGain.gain.setValueAtTime(safeMix, now);
                        delayDryGain.gain.setValueAtTime(1 - safeMix, now);
                    }
                    
                    // Update reverb parameters (set defaults if not mapped)
                    const reverbDecay = audioParams.reverbDecay || 2;
                    const reverbMix = audioParams.reverbMix !== null && audioParams.reverbMix !== undefined ? audioParams.reverbMix : 0.3;
                    
                    if (reverbNode && reverbWetGain && reverbDryGain) {
                        // Update reverb buffer if decay changed significantly
                        if (!reverbNode.buffer || Math.abs(reverbNode.buffer.duration - reverbDecay) > 0.5) {
                            reverbNode.buffer = audioEngine.createReverbImpulse(reverbDecay, reverbDecay);
                        }
                        
                        const safeReverbMix = Math.max(0, Math.min(1, reverbMix));
                        reverbWetGain.gain.value = safeReverbMix;
                        reverbDryGain.gain.value = 1 - safeReverbMix;
                    }
                    
                    // Log periodically to show values are changing
                    if (i % 5 === 0) {
                        const loggedParams = {
                            item: i + 1,
                            duration: duration.toFixed(0) + 'ms',
                            pan: pan.toFixed(2),
                            filterFreq: filterFreq.toFixed(0) + 'Hz',
                            delayTime: delayTime.toFixed(0) + 'ms'
                        };
                        
                        // Mode-specific parameters
                        if (samplerMode) {
                            const pitch = audioParams.pitch || 1;
                            const offset = audioParams.sampleOffset || 0;
                            loggedParams.pitch = pitch.toFixed(2) + 'x';
                            loggedParams.sampleOffset = (offset * 100).toFixed(0) + '%';
                            
                            // Show raw data values for mapped params
                            if (mappings.pitch?.path) {
                                loggedParams.pitchRaw = getValueByPath(item, mappings.pitch.path);
                            }
                            if (mappings.sampleOffset?.path) {
                                loggedParams.offsetRaw = getValueByPath(item, mappings.sampleOffset.path);
                            }
                        } else {
                            const frequency = audioParams.frequency || 440;
                            loggedParams.frequency = frequency.toFixed(1) + 'Hz';
                            
                            // Show raw data values for mapped params
                            if (mappings.frequency?.path) {
                                loggedParams.freqRaw = getValueByPath(item, mappings.frequency.path);
                            }
                        }
                        
                        if (mappings.filterFreq?.path) {
                            loggedParams.filterRaw = getValueByPath(item, mappings.filterFreq.path);
                        }
                        
                        console.log('üéµ Note ' + (i + 1), loggedParams);
                    }
                    
                    // Play tone with full effects chain
                    const filter = audioContext.createBiquadFilter();
                    const panner = audioContext.createStereoPanner();
                    const envelope = audioContext.createGain();
                    
                    let source; // Will be either oscillator or buffer source
                    
                    if (samplerMode && sampleBuffer) {
                        // SAMPLER MODE: Create buffer source from loaded sample
                        source = audioContext.createBufferSource();
                        source.buffer = sampleBuffer;
                        
                        // Get pitch (playback rate) parameter
                        const pitchRate = audioParams.pitch !== null && audioParams.pitch !== undefined ? audioParams.pitch : 1;
                        
                        // Apply master pitch transpose on top of data-driven rate
                        const pitchTranspose = parseFloat(document.getElementById('pitchControl')?.value || 0);
                        const transposeSemitones = Math.pow(2, pitchTranspose / 12);
                        source.playbackRate.value = pitchRate * transposeSemitones;
                        
                        // Get sample offset parameter
                        let sampleOffsetSeconds;
                        let sampleOffsetNorm;
                        
                        // Check if Random Chop Mode is enabled
                        const randomChopMode = document.getElementById('randomChopMode')?.checked || false;
                        
                        if (randomChopMode) {
                            // Random Chop Mode: Pick random start point at 1-second increments, play 5 seconds
                            const chunkDuration = 5.0; // Play 5 seconds from selected point
                            const startIncrement = 1.0; // Start points at 1-second intervals
                            
                            // Calculate max start time (leave room for the 5-second duration)
                            const maxStartTime = Math.max(0, sampleBuffer.duration - chunkDuration);
                            
                            if (maxStartTime > 0) {
                                // Calculate number of possible start positions
                                const numPositions = Math.floor(maxStartTime / startIncrement) + 1;
                                
                                // Pick a random position
                                const randomPosition = Math.floor(Math.random() * numPositions);
                                sampleOffsetSeconds = randomPosition * startIncrement;
                                sampleOffsetNorm = sampleOffsetSeconds / sampleBuffer.duration;
                            } else {
                                // Sample shorter than 5 seconds - use beginning
                                sampleOffsetSeconds = 0;
                                sampleOffsetNorm = 0;
                            }
                        } else {
                            // Normal mode: use data-driven sampleOffset parameter
                            sampleOffsetNorm = audioParams.sampleOffset !== null && audioParams.sampleOffset !== undefined ? audioParams.sampleOffset : 0;
                            sampleOffsetSeconds = sampleOffsetNorm * sampleBuffer.duration;
                        }
                        
                        // Crop duration: how long to play from offset point (in seconds)
                        const fullNoteDuration = document.getElementById('fullNoteDuration')?.checked || false;
                        let cropDurationSeconds;
                        
                        if (randomChopMode) {
                            // Random chop mode: always 5 seconds
                            cropDurationSeconds = 5.0;
                        } else if (fullNoteDuration) {
                            // Full note duration: play until next note starts (use noteSpacing)
                            const noteSpacing = audioParams.noteSpacing || 300; // Default 300ms
                            cropDurationSeconds = noteSpacing / 1000;
                        } else {
                            // Normal mode: use duration parameter (can be shorter than noteSpacing)
                            cropDurationSeconds = duration / 1000;
                        }
                        
                        // Store for starting/stopping later
                        source._offsetSeconds = sampleOffsetSeconds;
                        source._cropDuration = cropDurationSeconds;
                        
                        // Log first note for debugging
                        if (i === 0) {
                            const modeLabel = randomChopMode ? 'Random Chop' : 'Data-driven';
                            console.log(`üéµ Sampler (${modeLabel}): rate=${source.playbackRate.value.toFixed(2)}, offset=${sampleOffsetSeconds.toFixed(2)}s (${(sampleOffsetNorm*100).toFixed(0)}%), crop=${cropDurationSeconds.toFixed(2)}s`);
                        }
                        
                    } else {
                        // SYNTHESIZER MODE: Create oscillator
                        const frequency = audioParams.frequency || 440;
                        
                        // Apply master pitch transpose
                        const pitchTranspose = parseFloat(document.getElementById('pitchControl')?.value || 0);
                        let transposedFrequency = frequency * Math.pow(2, pitchTranspose / 12);
                        
                        // Apply pitch quantization if enabled
                        if (document.getElementById('pitchQuantization')?.checked) {
                            transposedFrequency = quantizePitch(transposedFrequency);
                        }
                        
                        // Get selected waveform type
                        const waveformType = document.querySelector('input[name="waveform"]:checked')?.value || 'sine';
                        
                        // Create oscillator using audio engine (handles standard, noise, FM, additive)
                        source = audioEngine.createCustomOscillator(transposedFrequency, waveformType, duration);
                    }
                    
                    // Configure filter
                    filter.type = document.querySelector('input[name="filterType"]:checked')?.value || 'lowpass';
                    filter.frequency.value = filterFreq;
                    filter.Q.value = filterQ;
                    
                    // Configure panner
                    panner.pan.value = Math.max(-1, Math.min(1, pan));
                    
                    // Configure envelope with anti-click protection
                    const now = audioContext.currentTime;
                    
                    // For samples, ensure minimum attack/release times to prevent clicks
                    const minSmoothTime = samplerMode ? 0.003 : 0; // 3ms minimum for samples
                    const attackTime = Math.max(minSmoothTime, attack / 1000);
                    const releaseTime = Math.max(minSmoothTime, release / 1000);
                    const durationTime = duration / 1000;
                    
                    // Use exponential ramps for smoother, more natural-sounding envelopes
                    envelope.gain.setValueAtTime(0.001, now); // Start near zero (exponential can't start at 0)
                    envelope.gain.exponentialRampToValueAtTime(volume, now + attackTime);
                    envelope.gain.setValueAtTime(volume, now + Math.max(attackTime, durationTime - releaseTime));
                    envelope.gain.exponentialRampToValueAtTime(0.001, now + durationTime);
                    
                    // Handle additive synthesis (create harmonics) - synth mode only
                    if (!samplerMode && source._isAdditive) {
                        // Create harmonic series (1x, 2x, 3x, 4x frequencies with decreasing amplitude)
                        const harmonicGain = audioContext.createGain();
                        harmonicGain.gain.value = 0.6; // Reduce fundamental
                        source.connect(harmonicGain);
                        harmonicGain.connect(filter);
                        
                        // Add 3 harmonics
                        const frequency = audioParams.frequency || 440;
                        const pitchTranspose = parseFloat(document.getElementById('pitchControl')?.value || 0);
                        const transposedFrequency = frequency * Math.pow(2, pitchTranspose / 12);
                        
                        for (let h = 2; h <= 4; h++) {
                            const harmonic = audioContext.createOscillator();
                            const hGain = audioContext.createGain();
                            harmonic.frequency.value = transposedFrequency * h;
                            harmonic.type = 'sine';
                            hGain.gain.value = 0.3 / h; // Decreasing amplitude
                            harmonic.connect(hGain);
                            hGain.connect(filter);
                            harmonic.start(now);
                            harmonic.stop(now + durationTime);
                        }
                    } else {
                        // Standard connection (both sampler and non-additive synth)
                        source.connect(filter);
                    }
                    
                    // Connect rest of chain (Filter ‚Üí Pan ‚Üí Envelope ‚Üí Reverb ‚Üí Delay)
                    filter.connect(panner);
                    panner.connect(envelope);
                    envelope.connect(reverbNode);
                    envelope.connect(reverbDryGain);
                    
                    // Start and stop source
                    if (samplerMode && source._offsetSeconds !== undefined) {
                        // Sampler mode: start at offset, play for crop duration
                        source.start(now, source._offsetSeconds, source._cropDuration);
                    } else {
                        // Synthesizer mode: standard start/stop
                        source.start(now);
                        source.stop(now + durationTime);
                        
                        // Start/stop FM modulator if present
                        if (source._modulator) {
                            source._modulator.start(now);
                            source._modulator.stop(now + durationTime);
                        }
                    }
                    
                    // Calculate note spacing: use mapped value if available, otherwise use speed slider WITH VARIATION
                    let noteSpacing;
                    if (audioParams.noteSpacing !== null && audioParams.noteSpacing !== undefined) {
                        // Mapped to data: use the value directly
                        noteSpacing = audioParams.noteSpacing;
                    } else {
                        // Not mapped: add automatic rhythmic variation for more musical feel
                        const speed = document.getElementById('speedControl')?.value || 1;
                        const baseSpacing = 500 / speed;
                        
                        // Add subtle random variation (¬±20%) to create natural rhythm
                        const variation = 0.2; // 20% variation
                        const randomFactor = 1 + (Math.random() * variation * 2 - variation); // 0.8 to 1.2
                        noteSpacing = baseSpacing * randomFactor;
                        
                        // Alternative: use item index for pattern-based variation
                        // Creates accelerando/ritardando effects instead of random
                        // const phase = (i / itemsArray.length) * Math.PI * 2;
                        // noteSpacing = baseSpacing * (1 + Math.sin(phase) * 0.3);
                    }
                    
                    // Apply rhythmic quantization if enabled
                    let actualDelay = noteSpacing;
                    if (document.getElementById('rhythmicQuantization')?.checked) {
                        actualDelay = quantizeRhythm(noteSpacing);
                    }
                    
                    // Update labeled displays
                    document.getElementById('itemValue').textContent = `${i + 1} / ${itemsArray.length}`;
                    
                    await new Promise(resolve => {
                        currentTimeout = setTimeout(resolve, actualDelay);
                    });
                }
            }
            
            isPlaying = false;
            isPaused = false;
            document.getElementById('playIcon').textContent = '‚ñ∂';
            document.getElementById('playText').textContent = 'Play Data';
            visualizerCanvas.classList.remove('active');
            audioEngine.stopVisualizer();
            clearNodeValues();
        }

        function stopPlayback() {
            isPlaying = false;
            isPaused = false;
            audioEngine.previousDelayTime = null; // Reset for next playback
            previousDelayTime = null; // Sync legacy var
            
            if (currentTimeout) clearTimeout(currentTimeout);
            audioEngine.stopVisualizer();
            
            document.getElementById('playDataBtn').disabled = false;
            document.getElementById('playIcon').textContent = '‚ñ∂';
            document.getElementById('playText').textContent = 'Play Data';
            visualizerCanvas.classList.remove('active');
            document.getElementById('itemValue').textContent = '--';
            clearNodeValues();
        }

        document.getElementById('playDataBtn').addEventListener('click', playDataSonification);
        
        // Redraw patch visualization on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log('Window resized, redrawing patch...');
                updatePatchVisualization();
            }, 250); // Debounce resize events
        });

        // Initialize page with clean defaults (runs immediately since script is at end of body)
        function initializeDefaults() {
            // Ensure synthesizer mode is selected
            document.getElementById('synthesizerMode').checked = true;
            samplerMode = false;
            audioEngine.samplerMode = false; // Sync with engine
            
            // Clear sample state
            audioEngine.clearSample();
            sampleBuffer = null;
            sampleFileName = '';
            sampleDuration = 0;
            
            // Hide sample upload section
            document.getElementById('sampleUploadSection').style.display = 'none';
            document.getElementById('sampleInfo').style.display = 'none';
            
            // Show waveform and filter sections (synthesizer settings)
            document.getElementById('waveformSection').style.display = 'block';
            document.getElementById('filterSection').style.display = 'block';
            
            // Clear file input
            const fileInput = document.getElementById('sampleFileInput');
            if (fileInput) fileInput.value = '';
            
            console.log('‚úÖ Initialized to synthesizer mode with clean defaults');
        }
        
        // Run immediately if DOM is ready, otherwise wait for DOMContentLoaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeDefaults);
        } else {
            initializeDefaults();
        }

        console.log('üéµ data 2 sound loaded and ready');
    </script>
</body>
</html>

